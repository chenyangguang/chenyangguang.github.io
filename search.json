[{"title":"经济机器是怎样运行的","url":"/2018-12-09-how-economy-running/","content":"# 对经济的兴趣\n我原先一直没兴趣关注关系经济学相关的东西。读书时代喜欢更多的热衷于谈论家国大事，总是幻想着仗剑闯天涯，怎么干一番开天辟地的，前无古人后无来者的大业，整天跟着时事到处转悠。到今天没被忽悠瘸，也真是庆幸。\n今天了解下经济机器是怎么运行了。因为我已经开始对投资，对赚钱，对经济的运行规律整出兴趣来了。\n这是我在一个视频里面看到的。不一定就对，看自己判断了。我把视频说的记录下来，再自己琢磨琢磨。\n开始了。\n\n# 经济机器\n经济就像一部简单的机器一样运行。但是很多人不大懂得这一点，或是对经济的运行方式持有不同观点, 于是导致很多不必要的经济损失。\n经济虽然看起来复杂，但是其实是以简单和机械的方式运行。经济由几个简单的零部件和无数次重复的简单交易组成,这些交易首先是由人的天性所驱动，因而形成三股主要的经济动力。\n\n+ 一，生产率的提高，\n+ 二，短期债务周期，\n+ 三, 长期债务周期。\n\n## 交易\n经济不过是无数交易的总和，而交易是一件非常简单的事情。交易时刻都在发生，我们每次买东西都是进行一笔交易。在每次交易中，买方使用货币或信用向卖方交换商品、服务或金融资产。**信用**在使用时和货币一样，因此把花费的货币和信用加在一起，就可以得出支出总额。支出总额是经济的驱动力，如果用支出金额除以销量，就得出价格。就这么简单，这就是交易。**交易**是经济机器的最基本零件，所有经济周期和动力都是交易造成的。所以理解了交易，才能理解整个经济。\n\n  一个市场由买卖同一种商品的所有买方和卖方组成，例如, 小麦市场、汽车市场、股票市场和千万种其他市场，经济就是由所有市场内的全部交易构成。把全部市场内的总支出和销量加在一起，就得到了了解经济运行所需要的全部信息。个人、企业、银行和政府都在以上述方式从事交易，用货币和信用，交换商品、服务和金融资产。政府是最大的买方和卖方，而政府有两个组成部分：即收税的中央政府和花钱的中央银行。央行控制着经济中的货币和信贷数量，因此不同于其他买方和卖方。央行通过影响利率和发行更多货币来实行这种控制。因此，央行在信贷流通当中发挥着重要作用。\n\n## 信贷\n  **信贷** 是经济中最重要的的组成部分，但也许是人们最不了解的部分。它之所以最重要，是因为它是经济中最大且最变幻莫测的一部分。贷款人和借款人与在市场中进行交易的买方和卖方没有两样。通常，贷款人希望自己的钱生出更多的钱，而借款人则想购买当前无法负担的某种东西。比如房子、汽车、或是进行投资，例如开办企业。借贷可以同时满足贷款人和借款人的需要。借款人保证偿还借款，成为本金，并支付额外的款额，称为*利息*。**利率高时，借贷就会减少，原因是贷款变得昂贵；当利率低时，借贷就会增加,原因是贷款变得便宜**。如果借款人保证偿还债务，而且借款人相信这一承诺，信贷就产生了。任何两个人都可以通过协定凭空创造出信贷！信贷看似简单，实则复杂，因为信贷还有其他名称。 信贷一旦产生，立即成为 **债务** 。债务是借款人的资产，是借款人的负债。等到借款人今后偿还了贷款并支付了利息，这些资产和负债将消失，交易得以完成。那么为什么信贷如此重要? \n\n  这是因为，借款人一旦获得信贷，便可以增加自己的支出。不要忘记，支出是经济的驱动力，这是因为**一个人的支出是另一个人的收入**。想想看，你每花一块钱，另一个人挣了一块钱；而你每挣一块钱，必定有别人花了一块钱。所以你花的越多，别人挣得就越多。如果某人的收入增加，其信用度就会提高，贷款人就更愿意把钱借给他。信用良好的人具备两个条件：**偿还能力**和**抵押物**。收入债务比率高，借款人就具备偿还能力。如果无法偿还，借款人还可以用有价值的、可以出售的资产作为抵押物。这样，贷款人可以放心地把钱借给他们。所以，收入增加使得借贷也增加，从而能够增加支出。由于一个人的支出是另一人的收入，这将导致借贷进一步增加，并不断循坏。这一自我驱动的模式导致经济增长，也正因为如此，才产生了经济周期。\n\n在一项交易中为了获得某样东西你必须付出另一样东西，长期来看，你得到多少取决于你生产多少。我们的知识随时间而逐渐增多,知识的积累会提高我们的生活水平，我们将此称为**生产率的提高**。一个善于创新和勤奋的人，将比那些自满和懒惰的人更快的提高生产率和生活水平。但在短期内不一定体现出来。生产率在长期内最关键，但信贷在短期内最重要。这是因为生产率的提高不会剧烈波动，因此不是经济起伏的一个重要动力。但是债务是这种动力，因为我们能够通过借债让消费超过支出，但是在还债时不得不让消费低于支出。债务量的波动有两大周期，其中一个周期持续大约5年至8年，另一个持续大约75年到100年。大部分人虽然能感受到波动，但由于离波动太近，每天、每周都身临其境，通常并不认为这是周期。\n\n如上所述，**经济的上下起伏不是取决于人们多么善于创新或勤奋工作，而是主要看信贷的数量**。我们先想象一个没有信贷的经济运行。在这样的经济运行中，增加支出的唯一办法就是增加收入，因此需要提高生产率和工作量。提高生产率和经济增长的唯一途径。由于我的支出是另一个人的收入，当我或者另一个人的生产率提高的时候，经济就会增长。我们如果观察各种交易，加以总结就会发现一条类似于生产率增长轨迹的渐近线。但是，由于我们借债，于是产生了周期，原因并不是任何法规，而是人的天性和信贷的运作方式。**借债不过是提前消费**，为了购买现在买不起的东西，你的支出必然超过收入。因此，你需要借钱，实质上是向未来的自己借钱。 你给自己设定了一个未来的时间，到那个时候，你的支出必须少于收入，以便偿还债务。 这样马上就形成了一个周期。通常一旦你借钱，就制造了一个周期，对于个人这样，对于整个经济运行也是这样。这就是为什么必须理解信贷，因为**信贷触发了一系列机械和可以预料的、将在未来发生的事件， 这就是信贷不同于货币的地方**。完成交易需要货币, 当你在酒吧用现金买一瓶啤酒时，交易立即完成。但是如果你用信用买一瓶啤酒，比如赊账，你相当于承诺今后为这瓶啤酒付钱。你和酒吧一起创造了一笔资产和一笔债务，你们凭空制造出了信贷。只有在你今后清偿了这笔赊账之后，上述资产和负债才会消失，债务才会还清，交易才会了结。\n\n现实生活中，大部分所谓的钱实际上是信贷。不要忘记，**在没有信贷的经济运行中，增加支出的唯一办法是提高生产**。但是在有信贷的经济运行中，还可以通过借贷来增加支出。因此，有信贷的经济运行能增加支出，使得收入的增长速度在短期内超过生产率的增长，但在长期内并非如此。**但是信贷不一定是坏事**, 只是会导致周期性变化。信贷如果造成超过偿还能力的过度消费，就是不良信贷。但是信贷如果高效率地分配资源和产生收入让你能偿还债务，就是良性信贷。例如，如果你借钱买一台大彩电，电视机不会带来任何收入让你偿还债务。但是你如果借钱买一台拖拉机，用它来收获更多的庄稼，赚更多的钱你就能偿还债务，提高生活水平。在有信贷的经济运行中，我们可以跟踪各种交易，观察信贷如何带来经济增长。\n\n举一个例子： 假设你每年挣10万美元，没有任何债务。你有不错的信用，可以借一万美元，例如用信用卡借。因此，你每年可以花11万美元，即使你的收入只有10万美元。由于你的支出是别人的收入，另一个人因此挣了11万美元，这个挣了11万美元的人如果没有任何债务，可以借1.1万美元。他可以消费12.1万美元，即使他的年收入只有11万美元。由于他的支出是另一个人的收入，而我们通过跟踪各种交易，可以看到这个过程不断自我强化。但不要忘记，**借债形成周期**，周期会上升，最终也会下降。\n\n## 短期债务周期\n下面我们来谈谈短期债务周期。随着经活动的增加，出现了扩张，这是短期债务周期的第一阶段。支出继续增加，价格开始上涨。原因是：导致支出增加的是信贷，而信贷可以即刻凭空产生。如果**支出和收入的增长速度超过所售出的商品的生产速度，价格就会上涨**。我们把价格的上涨成为**通货膨胀**。\n\n央行不希望通货膨胀过高，因为这会导致很多问题。央行在看到价格上涨时就会提高利率。随着利率的上升，有能力借钱的人会减少，同时现有债务成本也会上升，就等于你每个月的信用卡还款额会增加。由于人们减少借债，还款额度增长，剩下来用于支出的资金将减少，因此支出速度放慢。而由于一个人的支出是另一个人的收入，环环相扣，人们的收入将下降。由于支出减少，价格将下跌，我们称之为**通货紧缩**。经济活动减少，经济便进入衰退。如果衰退过于严重，而且通货膨胀不再成为问题，央行将降低利率，使经济活动重新加速。随着利率降低，偿债成为下降，借债和支出增加，出现另一次经济扩张。\n\n可见，经济像一部机器一样运行。**在短期债务周期中，限制支出的唯一因素是贷款人和借款人的贷款和借款意愿**。如果信贷易于获得，经济就会扩张。如果信贷不易获得，经济就会衰退。请注意，这个周期主要由央行控制。短期债务周期通常持续5-8年，在几十年里不断重复。但是，请注意在每一个周期的低谷和高峰后，经济增长和债务都超过一前一个周期。为什么会这样呢？这是人促成的。人具有借更多钱和花更多钱的倾向，而不喜欢偿还债务，这是人的天性。因此，在长期内，债务增加的速度超过收入，从而形成长期债务周期。\n\n\n尽管人们的债务增加，但贷款人会提供更宽松的信贷条件，这是为什么？这是因为，大家都以为形势一片大好！人们仅注意最近出现的情况。最近的情况是什么呢？收入一直在增加！资产价值不断上升！股票市场欣欣向荣！现在是繁荣时期！用借来的钱购买商品、服务和金融资产很划算。当人们过度借贷消费时，**泡沫**便产生了。因此，尽管债务一直增加。但收入也以相近的速度增加，从而抵消了债务。我们把债务与收入比率称为**债务负担**，只要收入继续上升，债务负担就可以承受。于此同时，资产价值迅猛上升，人们大量借钱来购买资产，因为投资促使资产价格日益升高。人们感觉自己很富有。因此，尽管积累了大量债务，收入和资产价值的上升，帮助借款人可以在长期内保持良好的信用度。但是这种情况显然无法永久持续下去，也确实没有持续下去。到了一定的时候，偿债成本的增加速度超过收入，迫使人们消减支出。\n\n由于一个人的支出是另一个的收入，收入开始下降。人们的信用因此降低，致使借贷减少。偿债成本继续增加，使得支出进一步减少，周期开始逆转。这时到达长期债务的顶峰，债务负担变得过重。美国、欧洲和世界上很多其他地区在 2008 年就发生了这一情况，日本在 1989 年和美国在 1929 年因同样原因发生了这一情况。 现在经济进入去杠杆化时期。在去杠杆化过程中，人们削减支出，收入下降，信贷消失。资产价格下跌，银行发生挤兑，股票市场下跌，社会紧张加剧。整个过程开始下滑并形成恶性循环。随着收入下降和偿债成本增加，借款人倍感拮据。随着信用消失，信贷枯竭，借款人再也无法借到足够的钱来偿还债务。借款人竭力填补这个窟窿，不得不出售资产。在支出下降的同时，出售热潮使市场充斥待售资产。这时，股票市场暴跌，不动产市场一蹶不振，银行陷入困境。随着资产价格下跌，借款人能够提供的抵押物的价值下降，这进一步降低了借款人的信用。人们觉得自己很穷，信贷迅速消失。\n\n支出减少、收入减少、财富减少、信贷减少、借债等等随之减少，这是一个恶性循环。它看起来与衰退相似，但不同之处是，无法通过降低利率来挽回局面。在衰退中，可以通过降低利率来刺激借贷。但是，在去杠杆化过程中，由于利率已经很低，接近0，从而丧失刺激功能，因此降低利率不起作用。美国国内的利率在 1930 年的去杠杆化期间下降到 0，在 2008 年也是如此。**衰退与去杠杠化之间的区别在于，在去杠杆化过程中，借贷人的债务负担变得过重，无法通过降低利率来减轻**。贷款人意识到，债务过于庞大，根本无法足额偿还。借款人失去了偿债能力，其抵押物失去价值，他们觉得受到债务的极大伤害，不想再借入更多债务。贷款人停止放贷，借款人停止借贷，整个经济体与个人一样都失去了信用度。\n\n## 怎样去杠杠化 \n那么应该怎样应对去杠杆化？问题在于，债务负担过重，必须减轻，为此可以采用四种方法。\n1. 个人、企业和政府**削减支出**；\n2. 通过债务违约和重组来**减少债务**；\n3. **财富再分配**，将财富从富人转给穷人；\n4. 央行**发行更多货币**。\n\n这四种办法被用于现代历史上的每一个去杠杆化过程。通常第一个措施是削减支出，个人、企业、银行和政府都勒紧裤腰带削减支出，从而能够减少债务。我们经常把这称为**紧缩**，当借款人不再借入新的债务，并开始减少旧债务的时候，你会以为债务负担会减轻。但情况刚好相反！支出减少了，而一个人的支出是另一个人的收入，这就导致收入下降。收入下降速度超过还债的速度，因此债务负担实际上更为沉重。我们已经看到，这种削减支出的做法引起通货紧缩，令人痛苦。企业不得不削减成本，这意味着工作机会减少，失业率上升。这导致下一个步骤，即必须减少债务！很多借款人无法偿还贷款。而借款人的债务是贷款人的资产，如果借款人不偿还银行贷款，人们会担心银行无法偿还其存款。因此纷纷从银行去除存款，银行收到**挤兑**，而个人、企业和银行出现**债务违约**。这种严重的经济收缩就是**萧条**。**萧条的一个主要特征是，人们发现，他们原先以为属于自己的财富中有很大一部分实际上并不存在**。\n\n我们再次以酒吧为例，当你用赊账的办法买一瓶啤酒时，是在承诺今后偿还酒吧的赊账，你的承诺成为酒吧的一项资产。但是，如果你不兑现承诺，不偿还酒吧的赊账，实际上是债务违约。那么酒吧的这项“资产”实际上一钱不值，它实际上是消失了。很多贷款人不希望自己的资产消失，同意债务重组。债务重组意味着贷款人得到的还款减少，或偿还周期延长，或利率低于当时商定的水平。无论如何，合约被破坏，结果是债务减少。贷款人希望多少收回一些贷款，总强过血本无归。债务重组让债务消失，但由于它导致收入和资产价值以更快的速度消失，债务负担继续日趋严重。削减债务和减少支出一样，令人痛苦和导致通货紧缩。所有这些都对中央政府产生影响，因为**收入降低和就业减少意味着政府的税收减少**。于此同时，由于失业率上升，中央政府需要增加支出，很多失业者储蓄不足，需要政府的财务资助。此外，政府制定刺激计划和增加支出，以弥补经济活动的减少。在去杠杠化的过程中，政府的预算赤字飙升，原因是政府的支出超过税收，在新闻中听到的预算赤字正是这种情况。\n\n政府必须加税或者举债，以填补赤字。但是，在收入下降和很多人失业的时候，应该向谁融资呢？富人。由于政府需要更多的钱，而且大量的财富集中在少数富人的手中。政府自然而然地增加对富人的征税，以帮助经济中的财富再分配。把财富从富人那里转给穷人，正在困苦当中的穷人开始怨恨富人，承受经济疲弱、资产贬值和增税压力的富人开始怨恨穷人。如果萧条继续下去，就会爆发社会动荡。不仅国家内部的紧张加剧，而且国家之间也会这样，债务国和债权国之间尤其如此。这种局势可以导致政治变革，有时是极端的变革。\n\n1930 年代，这种局势导致希特勒掌权、欧洲爆发战争和美国的大萧条。要求采取行动来结束萧条的压力越来越大。不要忘记，人们心目中的货币实际上大部分是信贷。因此，信贷一旦消失，人们的钱会不够花。人们迫切需要钱，而你一定记得，谁可以发行货币，中央银行可以。央行已经把利率降到接近 0 的水平，现在不得不发行更多货币。**发行货币与削减支出、减少债务和财富再分配不同，会引起通货膨胀和刺激经济**。中央银行不可避免地凭空发行更多货币，并使用这些货币来购买金融资产和政府债券。这种情况发生在美国大萧条期间，并与 2008 年再次爆发，当时美国的中央银行，即联邦储备委员会，增加发行了两万多亿美元，世界各地能够这样做的其他央行也增发了很多货币。央行通过用这些货币购买金融资产，帮助推升了资产价格，从而提高了人们的信用。但是，这仅仅有助于那些拥有金融资产的人，你看央行可以反行货币，但是只能购买金融资产。\n\n而另一方面，中央政府可以购买商品和服务，可以向人民送钱，但是无法印钞票。因此为了**刺激经济**，央行和政府必须合作央行通过购买政府债券，其实是把钱借给政府，使其能够运行**赤字预算**。并通过刺激计划和失业救济金来增加购买商品和服务的支出，这增加了人们的收入，也增加了政府的债务。但是这个办法将降低经济中的总债务负担，这是一个风险很大的时刻。决策者需要平衡考虑降低债务负担的四种办法。必须平衡兼顾通货紧缩的办法和通货膨胀的办法，以便保持稳定。如果取成适当的平衡，就可以带来**和谐的去杠杠化**。所以说去杠杠化可以是痛苦的，也可以是和谐的。怎样才能实现和谐的去杠杠化? 尽管去杠杠化是艰难的，但以尽可能好的办法来处理艰难的局势却是一件好事。这比杠杠化阶段大量举债产生过度失衡现象要好得多。在和谐的去杠杠化过程中，债务收入比率下降，经济实际上是正增长。同时通货膨胀并不是一个问题，这是通过适当的平衡所取得的。为了取得稳定的平衡，需要结合削减支出、减少债务、转移财富和发行货币的办法以保持经济和社会稳定。\n\n有人问，发行货币是否会加剧通货膨胀？**如果增发的货币抵消贷款的降幅，就不会引发通货膨胀**。不要忘记，重要的是支出。每一块钱的支出，无论支出的是货币，还是信用，对价格的影响都是一样的。央行可以通过增加货币发行量来弥补消失的信贷。央行为了扭转局面，不仅需要推动收入的增长，而且需要让收入的增长率超过所积累债务的利率，这是什么意思？主要的意思是，**收入一定是比债务增长得快**。\n\n例如，我们假设有个国家正在经历去杠杠化，其债务收入比率是 100%，这意味着，债务量相当于整个国家一年的收入。假设这些债务的利率是 2%，如果债务以 2% 的利率速度增加而收入的增长率仅有大约 1%，那么债务负担永远不会减轻，必须发行更多货币，是收入增长率超过利率。然而， 发行货币太容易了，而且这个方法比其他方法受欢迎。因此这个方法可能易于滥用。关键是避免像 1920 年代去杠杠化的德国那样发行过多的货币，从而导致恶性通货膨胀。\n如果决策层取得适当的平衡，去杠杠化过程就不会那样激烈，经济增长速度缓慢，但是债务负担会下降，这就是和谐的去杠杠化。\n\n当收入上升的时候，借款人的信用度提高。借款人一旦显得更有信用，贷款人就会开始恢复贷款。债务负担终于开始下降，人们可以借到钱，就可以增加消费。经济终于开始恢复增长，长期债务周期从而进入通货再膨胀阶段。去杠杠化如果处理不当，会非常可怕；如果处理得当，最终将解决问题。为了使债务负担下降和经济活动恢复正常，大约需要十年或更长的时间，因此有“**失去的十年**”这种说法。\n综上所述，经济当然要比这个模式复杂一些。然而，把短期债务周期、长期债务周期和生产率增长轨迹结合起来分析，我们会得到一个不错的模式，可以看清我们在过去和当前的出境以及未来可能的发展方向。\n\n# 小结\n最后，希望学到三条法则： \n+ 第一，不要让债务的增长速度超过收入，因为债务负担最终将把你压垮。\n+ 第二，不要让收入的增长速度超过生产率，因为这最终将使你失去竞争力。\n+ 第三，尽一切努力提高生产率，因为生产率在长期内起着最关键的作用。\n学习了。\n\n","tags":["我不知道的事"]},{"title":"go 爬虫爬取深圳房源信息","url":"/2018-12-07-sz-house/","content":"\n没事就捣鼓一下爬虫，弄点数据玩一下吧。\n今天就拿下深圳房源来弄一下。\n花了半小时加调试正确。\n\n[深圳房源价格概况](https://github.com/chenyangguang/hundun/blob/master/sz-house/summary.go \"深圳房源概况\")\n","tags":["爬虫"]},{"title":"考验你的时候到了","url":"/2018-12-02-do-it-now/","content":"\n## 周末发版\n周六上线, 大版本的升级。虽说不是太大波动但也是一波三折。做个记录吧。可以改进的地方当然还是很多的。\n昨天还想着总结一下的。但是昨天其他部门折腾到晚上 22:00 多。回到家都 11:30 了, 当时没来得及仔细回顾。洗洗睡了。\n今天来回顾一下都用了哪些上线操作技巧。\n\n### 就位 \n*8:30* 我就已经就位了。基本上进入上线的节奏了。但是同时上线的其他部门的四个部门还没有准备好。我需要等其中一个部门的人将与本次需求相关的大概几十万数据发过来, 进行初始化。\n于是写好上线文档，重新梳理一遍本次开发的源码逻辑，流程。确认顺利走了一遍。将后端单元测试 *go test* 走一遍。确认开发环境和测试环境下没有问题的。\n\n### 准备\n*9:00* 开始细化前一天（周五）与架构师讨论修改之后的文档, 包括数据初始化的改动。本来周五下午我准备封闭将要上线的 dev-feature 功能分支的。但是架构师过了一遍之后。认为我初始化的数据有点问题。主要是初始化不够彻底，留有少许残余的没初始化到。于是我重新修改了两版方案。其中初始化行业和地址字典部分，我改为原先从上传文件走脚本修改，改为导入临时表, 然后使用联表查询，依据不同条件进行批量更新。\n等初始化的数据，一直催他们，还是没有给到正式线的初始化数据。\n所以在 *15:30* 拿到初始化数据之前。我依次做了这几件事情: \n\n0. 无关的代码注释，多余的 log 打印去掉。\n1. 合并前端代码，提交版本库。 因为需要拉 node_module 目录，所以提前准备好前端代码镜像。\n2. 合并后端go代码，提交版本库待发布分支。\n```\ngit checkout master \ngit fetch \ngit checkout dev-feature\ngit rebase  master -i \n# 然后保留一个功能点的 commint ,其他的 commit 修改为 squash \n# 这样可以保证主干分支 master 的干净, 相当于本次 100 个 commit 汇成了一个 commit\n```\n3. 再次细化上线文档。 \n  + 将数据库表变更操作每条将要执行的 sql 按照执行顺序, 按照四个功能块列出来。细化到每一条 sql, 包含变更前的查询和变更后的确认 sql 全补上。 \n  + 初始将修改的功能点 1-7 罗列出来。上线前给架构师再过一遍。架构师确认无误。\n  + 加上接入监控部分详细描述。\n  + 确认要部署的 docker 集群 ip。\n4. 提前配置好配置服务器的相关域名，开放端口，各项敏感参数，签名。\n5. 配置线上开放的 API . 发布，申请审核通过之后，进行对应的业务线授权。\n\n### 初始化\n开始所有的数据库操作之前，都先备份。\n```\nmysqldump -uroot -p dbname table_name > table_xxx_20181201.sql\n```\n*16:00* 千呼万唤始出来，终于等来了初始化数据。我依次按照我的文档。执行了初始化。一开始收到初始化文件时，想着用 **rsync** 去上传文件的。但是行不通。改为 **rz** 同步初始化数据文件到服务器。然后打算从终端直接导入。\n```\nmysqldump -uroot -p db_name < change.sql \n```\n结果不行。又改登陆数据库先进去， 然后\n```\nsource /dirpath/change.sql\n```\n这下导入了。之后开始加字段, \n```\nALTER TABLE X ADD COLUMN xxx VARCHAR(50) NOT NULL COMMENT 'XXX';\nUPDATE TABLE ...\nALTER TABLE ADD INDEX (`YYY`);\n...\n# 还有一顿的操作, 按流程文档走。\n```\n初始化历时 30 分钟左右。\n此时已经 *16:30* 左右了! 根据上线次序，必须其他三个部门全部上线完，我才能上线。但是其中的一个部门还在初始化。\n然后继续等。结果，等到了晚上快 20:00 点，才等来了消息: 其他部门初始化完成了，这下我才可上线。在这中间，我又把本次接入的出入的接口加上监控项目。这样，代码一上线，我就可以开始变看日志，边看监控发现存在的问题了。\n\n### 上线\n于是我用了 7 秒就把后端所有的镜像部署上去了。为啥？因为我在等待其他部门操作期间，把所有的镜像都准备好了。万事俱备，只欠灭霸的一个响指了。哦，好像哪里不对啊。\n紧接着又上线前端的容器。\n看日志，发现有一个错误级别的。反馈是数据库有一个字段找不到！这个字段是第八版本中修改的！赶紧加上。这回后续时间内那个错误级别日志消失了。\n然后联合线上回归。又发现几个问题。马上跟进！\n原来其中有一个问题是我这边的，有一个表的有关时间字段设置的 int(11) 没有 UNSIGNED ! 长度不够。所以我改了一下这个字段长度。\n```\nALTER TABLE table_name CHANGE `x_column` `x_column` int(11)  UNSIGNED  NOT NULL DEFAULT 0 COMMENT '过期时间';\n```\n然后再验，还是不够。原来另一个接口返回的时间戳是精确到毫秒级的时间戳， 从 2147483647 扩大到 4294967295还是不够。所以我改为 bigint 之后才行。\n其他问题，协助他们验证的线上的 bug 进行日志跟进。依次都化解了。\n\n验证完，都已经 22:00 了。\n然后就坐地铁回家了!\n\n## 小结\n1. 永远准备好应对任何来自生产环境的异常问题。生产环境和测试环境不可能完全一致, 只能无限逼近。 \n2. 单元测试能多写就多些，必要的加上压测。\n3. 操作流程要清晰。\n4. 要有全局观。\n5. 响应要一直保持足够快。\n","tags":["计算机技术"]},{"title":"混沌？馄炖?","url":"/2018-11-28-hundun/","content":"\n闲来没事，看了下 [gocolly](https://github.com/gocolly/colly \"colly\")，练手搞一个爬虫，搂了一遍最新的腾讯官网的招聘信息。\n这种不需要登陆的网站是最容易爬到的。\n很简单，还是给自己小结过一下。\n\n\n因为无须登陆，所以这条虫子几乎是官网的基础的例子\n使用 Chrome 浏览器打开[腾讯招聘官网](https://hr.tencent.com \"tx\"),  *F12*, 随便在搜索框里面输入一点比如 go, 就进入一个分页的搜索结果列表页。定位到招聘的职位那几栏，发现是用的 table 框起来的。找官网的基本例子依样画葫芦。\n\n```\n\tc.OnHTML(\"#position tbody tr\", func(e *colly.HTMLElement) {\n        writer.Write([]string{\n            e.ChildText(\"td:nth-child(1)\"),\n            e.ChildText(\"td:nth-child(2)\"),\n            e.ChildText(\"td:nth-child(3)\"),\n            e.ChildText(\"td:nth-child(4)\"),\n            e.ChildText(\"td:nth-child(5)\"),\n            e.ChildAttr(\"a\", \"href\"),\n        })\n\t})\n```\n\n结果爬取的结果除了想要的那些 tr 行之外，表头和地步的分页的数据也给弄进去了。\n这不是我想要的，决定过滤一下。于是改进一下小版本的只搂需要的选项。\n\n```\n\tc.OnHTML(\"#position tbody tr\", func(e *colly.HTMLElement) {\n\t\titemClass := e.Attr(\"class\")\n\t\tif strings.EqualFold(itemClass, \"even\") || strings.EqualFold(itemClass, \"odd\") {\n\t\t\twriter.Write([]string{\n\t\t\t\te.ChildText(\"td:nth-child(1)\"),\n\t\t\t\te.ChildText(\"td:nth-child(2)\"),\n\t\t\t\te.ChildText(\"td:nth-child(3)\"),\n\t\t\t\te.ChildText(\"td:nth-child(4)\"),\n\t\t\t\te.ChildText(\"td:nth-child(5)\"),\n\t\t\t\te.ChildAttr(\"a\", \"href\"),\n\t\t\t})\n\t\t}\n\t})\n```\n只爬一页不够啊，我需要全部的招聘信息，然后再加一下获取下一页的链接。让它爬完一页之后接着下一页，直到爬完所有的招聘。\n\n```\n\tc.OnHTML(\"#next\", func(h *colly.HTMLElement) {\n\t\tt := donain + h.Attr(\"href\")\n\t\tlog.Printf(t)\n\t\tc.Visit(t)\n\t})\n\n```\n\n这样一来就拿到腾讯官网全量的数据了。\n还是向 shawjia 学习，多提交一些自己的开源项目, 哪怕是最基本的练手的项目。\n今天是个开始，这顿 [馄炖](https://github.com/chenyangguang/hundun \"馄炖\") 就是个见证。(一直不知道开始的项目应该叫啥名，索性就处在混沌之中吧。) \n\n\n\n","tags":["go","代码"]},{"title":"Emacs as golang IDE","url":"/2018-11-27-ide/","content":"## IDE\n据我观察，很多程序员们喜欢 IDE 的原因在于工程化全局查询，函数定义, 复制粘贴， 其他的模块化插入代码块，是没有太多吸引力的。\n\n## 作为 Go 开发 IDE\n[emacs as golang ide](https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/go \"ide\") 这里有基本的配置。\n*godef* 安装一下可以解决函数定义的出处查找问题。没事就来一下: *C-c C-j*, 立马追到底。包括 *go/src/* 目录也能追杀到底。\n查找使用 Emacs 本身的查找 *find-grep* 命令快的不行, 老方式： *Alt+x find-grep 要查询的关键字* 。效果图如下：\n![emacs-command](./emacs-command.png \"emacs-command\")\n\n从上面的效果途中可以看到很多中查找方式，如果要在当前工程目录找，可以使用 *projectle-grep* 这个命令。\n解决了这几个问题。Emacs 用来写代码不是一般的爽。有一种上瘾的感觉。特别是 spacemacs 兼顾了 VIM 与 Emacs 两者的长处。不多说了，先让代码飞一会儿!\n\n","tags":["Emacs"]},{"title":"使用org-mode管理自己的日常计划目标","url":"/2018-11-25-i-do-not-know/","content":"## org-mode杂事\n使用org-mode有些时日了。整理一下最简单的日常使用方式。\n\n### 自助服务\n因为我是用的是 [spacemacs](http://spacemacs.org/ \"spacemacs\"), 所以如果是 **org-mode** 相关的指令，是可以直接使用 **Alt+X** 调起这些命令去执行的。或者直接 **Ctrl+h org** 看下帮助文档。\n![org-help](./org.png \"org-help\")\n\n### GTD\nGTD就是Getting Things Done。以目标为导向去完成计划。可以配合番茄闹钟工作，更有疗效。\n\n### 我的org-mode在干什么\n我每天的计划是每天做三件值得做的事，外加一个小结。其中每件事按照A、B、C分三个由高到低的轻重缓急层级，并且设置开始做的时间点和截止时间点，完成时会补录结束之间。Like this: \n![my-org](./my-org.png \"my-org-png\")\n\n### keys \n[Here](https://lucaseo.github.io/2018/02/20/howtodo-20180220-1/ \"here\") 有一篇文章教怎么在 *Hero* 的博客的 **source/_post/对应文章路径** 中 弄进来一张自定义的图片。\n","tags":["Emacs","我不知道的事"]},{"title":"周末","url":"/2018-11-11-weekenday/","content":"\n## 双十一什么的\n  好像跟我没啥关系, 这一天花了50块钱，周末了，吃饭加水果。想买个Bose QC 35,  要2000+,AirPods 也需要至少1200+, 暂时算了。还没到时候。\n\n## 写博客的理由\n  与其说是写博客的理由，还不如说是梳理自己思路的方式吧。不为谁看，谁不看。任凭自己的思路铺展开来，想到哪里，就写到哪里，不必像儿时的语文课作文，不必像高考的证明题，也不像大学毕业设计。总之，我现在想的是什么，就写什么。无需关心点赞，更不用管什么转发量。\n\n## 近期锻炼侧重\n  由于脚髁的皮外伤还没有完全好，最近调整了锻炼的侧重比例, 增加了平板支撑的科目。人的身体的中心在腰腹部，所以需要将身体的核心位置练强壮一点。平板支撑锻炼的身体的核心肌肉群, 经过一段时间早晚锻炼，目前单次最长可以支撑到90s了。每日两次，每次三组，加起来一天差不多12分钟。\n\n\n## 无惧野狐3段了\n一年前，我还是野狐一段水准。9月份开始，对战野狐2段我已经有了超过70%的胜率了。10月份甚至达到过4段, 但是很不稳定，从2段上去，一段时间连胜，一段时间连败，反反复复，很不稳定, 所以还是3段中的水平吧。后来分析了一下，是复盘很少。目前腾讯围棋的绝艺复盘，已经开放给大众了。一天下两盘，可以收获4个积分，5个积分可以申请一次绝艺复盘, 查看了自己的一下胜率分布，发现赢的多数是我逆转的棋。进入了11月份之后，对战3段，已经有了60%的胜率了。但是我现在坚持一天最多下两盘质量局。希望多一点时间发现自己薄弱的环节，比如布局，贴身格斗。争取在年底前，能将棋力提升至4段中上的实力稳定线上。\n\n\n## 行走\n  我个人感觉，自已最有想法的时候，往往是在路上。在行走的路上，一边走，一边由着思绪散开，漂流。任它们游走，旋转，重装，组合，平时工作日里面种种困顿烦扰的问题，随着路途的遥远慢慢蒸发，随着海拔的提升渐渐稀释，随着时间的运转徐徐淡色。我喜欢行走，到目前为止，我人生中的几次重大选择都是在极目远眺的行走时拿定主意的。\n  五岳中，还有西岳华山，北岳恒山，中岳嵩山没有涉足。年底前找个时间去一趟，看看。有个同事会问我，我看你那么喜欢去爬山，但是你说你，爬完回来也没啥变化啊。是啊，爬一座山，可能真的没啥变化的。但是我能出去看看别的地方的真实的存在，涨涨见识。突然想到以前看到的有个登上喜玛拉雅山顶的人说的：“因为山就在哪里”。“这能长什么见识，爬山就能长见识啊”？ 我一时无语。好比看一本书，我很可能读完，会感觉没啥收获啊，那我下次还会不会读书呢？会。为什么？因为无论你觉得或者不觉得，我经历过的事情，会对我的认知，对我的世界观，人生观有一个看不见的作用。没法预料哪一个瞬间，你就想到曾见过的一朵盛开的蓝莲花，也没准哪一个时刻，就会浮现雪山上的石头缝里的一株野草, 也没准某个夜深人静的时候，就勾勒起野营时漫天的繁星。它们已经埋在我的记忆里，根植于我的血脉里。它们告诉我，岁月流逝，生命坚韧，星空浩瀚。而我见识过繁花的一瞬，我手抚过山巅上的流云，我迎过高空的日升日落。这就是我关闭朋友圈半年来, 真实的活过, 思考过。\n\n","tags":["点滴"]},{"title":"十月","url":"/2018-10-31-october/","content":"\n## 十月就这样过去了\n\n国庆节期间一双拖鞋，两天，反穿武功山。\n还是喜欢以前一边徒步一边记笔记好玩。那样能记录实时的真的感受。现在是拍拍风景照，发发群，吹吹水，就这么过去了。\n\n## 第一次滑旱冰\n月底时，部门组织的活动，人生中的第一次滑旱冰。摔了差不多十个狗吃屎。还把脚踝外部磨破了一块皮。搞得好几天没结痂。连游泳跑步也不行了。还是保护自己不周到, 以后得注意了。\n\n## 定投\n\n10月11号开始定投。开始管理自己的工资了。以前从来没有投资过，这次长期定投预计是2-3年。目前累计收益6.82%, 午餐可以加几个鸡蛋了。定投需要耐心，买到指数基金。买的是趋势，买的是国运。\n\n\n## 开发业务\n加班太多，领导找去谈话了。其实我完全没必要加班的。但是白天处理的杂事太多，而且需要#bug修复的多，主干开发白天时间严重不够。另外就是白天来得早啊，晚上7，8点回去，都记加班到10小时，11小时了, 这个怎么算了。\n\n\n## 年底前定个小目标吧\n\n年点前，开发一款能平台通用的应用产品并上线。\n名字还没想好。初步采用 weex 来写。\n","tags":["点滴"]},{"title":"记一个API20倍性能优化","url":"/2018-09-24-optimize/","content":"\n## 同步\n我接手的其中一个项目中，有一个核心的业务是提供用户信息同步功能。这个同步API后头还连着其他关联业务，比如创建账号，查询信息，下载信息等。\n\n## 历史问题\n这个业务历史悠久，主要是为各产品部门调用该接口，上传用户信息, 提供线上服务做支撑。而这个同步接口，从上线到目前为止，已经优化了35个版本！目前性能为： 同步26000个用户信息，耗时45分钟左右。调用方也是经常用到心里发毛。所以现在交到我手上了。\n\n## 动手\n  + 了解需求 沟通, 游走各个关口。 读源码， 画流程图。\n  + 调查问题瓶颈, 监控系统(prometheus)分析响应时间，耗时。 断点设置，日志，数据库统计耗时。\n  + 开会讨论, 讨论痛点，下决心，职责划分，争论方案。\n  + 开会讨论, 下决心, 职责划分，争论方案。\n  + 开会讨论, 定方案, 开发周期，拉一个架构师和技术副总监一起过。\n  + 边写测试单例，边构思。\n  + 开会, 了解进度，方案可行性。\n  + 完成本地批量测试, 模拟客户端访问。引入 golang 自带的 pprof 工具。\n  + 重构数据库, 优化表结构，加索引等。\n  + 重构分支流程, 码代码。\n  + 开发集中。中间又出几个问题，又来了几次会议，不断切遇到的问题，以及之前问题的盲点，逐一条出解决方案。\n  + 合并\n  + 单元测试\n  + 压测\n\n## 优化点\n  + 数据库表调整，添加索引。\n  + 同步阶段，断开一个占用耗时将近1/3的外部接口,将外部接口交互流程滞后执行。\n  + 批量处理，单个用户的信息，批次查询，然后本地计算，最后批量入库。\n  + 合理地利用goroutine。\n  + 等。\n\n## 效果\n  部署到测试环境, 26000个用户月50s内同步完。优化后版本同步速度获得约20倍质的提升!暂时做个笔记吧。这个版本部分工作，是在“山竹”台风到达那天完成的。还好人没事,凌晨从公司回到了家。\n线上的性能，待我上线确认之后再更新。\n\n## 小结\n遇到问题，找到病因，对症下药，合理使用开源工具(比如 prometheus 和 pprof 在分析瓶颈中发挥重要的作用)。每一个解决掉的问题，都是我下一步前进的动力。\n","tags":["Web"]},{"title":"泰山观日出","url":"/2018-08-27-taishan/","content":"\n# 出发\n我愿追随自己年轻时的血气方刚，再来几次出发，远行。\n\n## 半夜闹钟\n上周六2018-08-25，怕半夜赶不上车，弄了3:00,3:30，4:00的闹钟。好在及时在第一波闹钟的提醒里起来。赶在4:20到了机场。\n\n## 飞机\n在这个城市四年了，我是第一次到这个机场。一开始我以为自己时间还是挺多的。但是只是好奇了几下这里候机的来来往往的人，心里暗暗感叹了一会机场的穹顶，一路从安检走到登机口，感觉绕过过了两个操场。\n早上6:10的飞机。\n头一次总飞机。那个心情真的是, 好爽啊。特别是一面忐忑着，一面又极其激动地坐着飞机，轰隆隆地在跑道上奔着，地面的草向后面越来越快的划退，奔着奔着，后背一靠，前头拔高，脚底感觉有一股厚实的板顶着，飞起来了！要上天了！\n\n## 济南的夏天\n热。\n\n## 泰安的小饭馆\n香，实惠的小菜。\n\n# 泰山\n泰山北斗，可不是比衡山难爬嘛! 十八盘。。。。。。， 给我多来几盘。\n## 日出\n山顶扎一小帐篷，租一军大衣。本以为可以好好地在石板地上睡到第二天至少4点吧。。。。。。, 谁知道凌晨1点之后，陆续地帐篷周边热闹起来，压根睡不着觉。打游戏的，聊天的，嬉戏的，吃东西的，喊冷的，哼小曲的，小孩哭闹的。。。。。。许多观日出的人不远万里的，赶来等日出的好日子。4点起来，想找个位置，附近的所有能站人的石头面，都被人占着了。。。。。。后来绕树丛里，钻爬到一处人少的稍险的高台上。占着。\n5点半左右，出来了!\n日出时，天际的云海光影和初生的圆盘, 真的是不可阻挡, 那种透射出来的光芒柔韧而坚实。三个山头的人禁不住齐齐呐喊一阵。各种手机姿势抬着，留下在泰山上的非凡的金色映像中。\n\n## 趵突泉\n三个大泉眼。\n\n## 老舍纪念馆\n那个老舍的房子好封闭！\"济南的冬天\"就是在这样的院子里写出来的吗？好怀念那个时代的人对天地人的感受。\n\n# 在路上\n不断行走，在路上。\n","tags":["行万里"]},{"title":"衡山","url":"/2018-08-19-hengshan/","content":"\n# 衡山我来了\n初次听说衡山，是初二时学地理, 要考试，背书，弄了个顺口溜:\"东西南北中，秦华衡恒嵩\"。而且，这五座自古为游人津津乐道的心目中的憧憬，到底是晚来得太久了。\n这次跑往衡山来爬。并不是想扎人堆，而是想出来散散心, 走走，舒展舒展筋骨。\n\n\n## 太庙\n入乡随俗，上山前，到太庙烧一炷香，拜一扣佛。\n\n## 南天门\n西面大风夹着云雾沿着南天门的山脊，扇吹过来，将衡山一分为二。\n\n## 祝融峰\n到顶了。\n\n## 累了\n到过，这是起点。\n过了，不想写了。\n\n\n","tags":["行万里"]},{"title":"holiday","url":"/2018-06-18-holiday/","content":"\n## 澳门半天(2018-06-16)\n平日锁在一个笼子一样的办公室，今日看了半天书，心里烦闷，翻箱倒柜中，发现港澳通行证还要次数。于是买个 14:30 的船票一路从蛇口出发，往澳门去了。目标是观光塔。一路中有几件事蛮有意思的。记一下。\n\n### 第一件, 奇怪的身边船客。\n本来我的船票是二楼第二排靠窗的，结果有个穿厚外套的老者先到，坐到我的位置去了。等我上去示意他坐了我的舱位时，他说他想坐舷窗，要和我换。我想着照顾老人，那算了。原本我也想靠外坐，看海景方便些。后来他就一直用手机看信息去了。直到我中间拿出《区块链原理、设计与应用》的书看上一段时间。他趁我翻页时，要借书看看封面和目录，随手翻了下。然后眼睛一亮，说道：“这本书可不可以借我一分钟拍个照”？我有点楞，但马上回过神来：“行，你要想看，你先拿去看吧。没事，我回去可以接着看的”。他赶紧解释：“哦，那倒不用，我想借来拍几张”。“可以，可以。给”。我就看他那眼睛像瞄上一个猎物一样。拿着这书，快速翻着，拍了几张。然后按下一个语音按钮，对着手机发起语音来：“张秘书，我刚才给你发一本书的图片过去，你去下个单，......另外，调研一下，是否还有没有同类的书，照着订几套，。。。。。。先订１０套，xxx级别以下的都让他们先学习学习。好吧。。。。。。”。有些其他的话就记不清了。总之，可以听出来，我后边舷窗的这位，可不是一个平常的游客！而且，仅凭船上一个游客看的书，他怎么就马上叫人下单去？这让我百思不得其解。可见这个人，对前沿技术或者对市场有着某种嗅觉。这个有点令我感到意外。\n\n### 第二件，233米高空漫步。\n在路上就很期待此次行程有所心理突破的。233米，我是奔着那个蹦极来的。车从桥上横渡海岸时，就远远看着这个观光塔了。塔身是个多变型，塔尖下方有一个圆环型观光台。有一侧斜拉着两条锁绳。坐电梯上去，透过玻璃门，看到地面逐渐下沉，心里开始打鼓了。到了58层时，靠着玻璃窗户，站在那些透明的板上，看着西面的车那么小，人影那么小。生怕自己掉下去了。蹦极的人，从上面双手伸展，打个十字，嘶喊着前倾倒下来，58层的人群围拢起来，一起探头出去看。哈哈，我的心里想：这些人啊。。。。。。\n61层。正是各种活动的入口。拿来一张价格表。好贵！那个蹦极要4000多澳元！只有一个太空漫步是三位数的。780澳元。(出门如果没兑换，到了景点一律是 1:1 汇率兑换，略亏)\n囊中羞涩，最后，只玩了一个太空漫步。夕阳西下，233米高空跨出边沿往下看，还是有些怕。多看了几次之后，坐了一些动作。就坐在边沿上看往下探。深呼吸几次。终于不怕了。哈哈哈哈。蛮有趣！\n中间有个插曲，是东西存放柜子时，发现只能用 30 港元，结果只能去兑换。刚兑换完，然后一个长的很清秀的妹子没带现金，正要找那些开发票的人沟通，说是票买了，但是没有现金无法开柜存包，结果开发票的给建议向我借点，然后转给我。我说我们直接用一个箱子放得了。我手机快没电了，向她借了充电宝。然后她就去蹦极去了！真会玩。胆儿也太肥了！\n高空漫步结束后，坐上面又看了十几页《区块链原理、设计与应用》。等她跳完回来时，瞄了她一眼，很平静。那一刻，感觉那个妹子好漂亮啊。然后，就把箱子的东西还她。互相道谢之后，各自奔自己的行程去了。因为超时了，她要转账，我说当充电费了。然后，就没然后了。\n\n## 珠海海洋王国一天(2018-06-17)\n在珠海休正，一大早就去深圳最大的两个公园山顶看了。感觉珠海是个宜居不宜游的城市，不知道是放假还是人口本来就少，感觉这里的压力，应该比深圳小很多。行人走路都那么悠闲。\n坐公交往珠海最南端出发。那里是长隆。\n坐过深圳的木质过山车，这里的过山车，全程没太大感觉。甚至失重感也不是那么强烈。可能和前一天的澳门高空漫步有点关系。\n海豚和白鲸剧场表演，让人感叹，动物很奇妙。\n各种海底生态中才有的动物，在这里看到了。最震惊的还是水母。追逐光ppppp的神奇动物。\n我在想，为啥这里的馆能做到那么大，那些生态怎么维持？那么多海底动物在里面，怎么维持平衡？怎么喂食所有的动物呢？水的循环做的很好。水质很干净。\n然后，今天还碰到了昨天和我存放一柜子背包的那个妹子。她和她男朋友一块儿也到这里游玩来了。太巧了。\n\n## 小结\n旅途中，最重要的就是接触来自不同世界，说着不同语言的人。不少有着奇幻之旅的游客，不远万里，汇到一起，然后又散去。\n然后，在路上，遇到妹子的概率比宅在家里，要高很多。\n世界很大, 不可思议的事情，不同寻常的人很多，很多。\n常出去走走。\n应该像以前去西藏一样，将路上所有的所思所想都记录下来。很有意思。\n\n","tags":["点滴"]},{"title":"最近","url":"/2018-06-05-stronger/","content":"\n## 变动\n过去半年，经历了不少新的东西。\n遇到不少问题。不过都已经过去，都一一过去了。\n这半年的工作遇到的问题，比去年加起来都多。主要是因为工作变动，原先从事 php 和 python 开发转到 golang 上面。然后是工作环境从 ubuntu 切到 windows 上。谁说开发工具不重要的，真的到一个团队里面去的时候，周围的工具链还是很影响效率的。\n\n## 无题\n和 golang 相匹配的工具链一大坨，docker, elk, beego, k8s 都需要时间消化，然后自己还要对基础进行补课(数据结构和算法依然是短板)， 对于网络协议的理解还是粗浅， 对mysql, redis 的使用还不够深熟。这些还只是闲暇时间的事情。日常工作中又常是各种旧的系统留下的 bug, 排查日志，定位问题，运维修复。一边还得和别的部门打交道，交接沟通头痛的需求，“过堂”......\n\n\n## 小成\n不过这半年过得还是蛮充实的。处理的问题多了，慢慢地也就心里有点数了。对于某些事情的轻重缓急有了划分，渐渐抽出时间实现一些认为更有价值的东西去。\n而且每迈过一道坎，就信心更增加了一些。后面遇到问题，就不至于那么慌了。\n\n强者需要面对更多的困难。\n","tags":["点滴"]},{"title":"ball-lightning","url":"/2018-05-20-ball-lightning/","content":"\n### 故事情节\n《球形闪电》是刘慈欣早年的科幻作品。以第一人称讲述了一个少年孩童时代，因一晚狂暴的雷雨之夜被球形闪电夺去父母性命的机缘下，从此迷上了球形闪电的科幻故事。\n\n### 读感1\n大学毕业之后已经很久没看过科幻小说了。现在看小说和以前有最大的不同就是快速浏览。不再像以前那样仔细咀嚼。而且都是不敢兴趣的章节往往直接跳过去。另外就是，会被中间的某些情景突然带到现实世界中，应该是\"分神\"。不是那种纯想象的情景。这或许是就是看到和接触到的现实的事物多了，想象力就慢慢的衰弱的感觉吧。一度还对个别场景下的描述觉得可疑，觉得那些不可能发生的。\n\n### 读感２\n可是，科幻小说真正的目标不就是联系现实，并且超越现实，思考和憧憬那些美好的未知事物吗？这些想象创造出那些过去和现在都不存在，在未来有可能存在的创造物和事件。比如古代的封神演义里面的千里眼，顺风耳等，现在都已经有了实际的对应事物。但是真正令我们着迷的永远是未知的事物, 比如黑洞，星际旅行。无论是宏观还是微观上的想象力，都是这个宇宙的美好。\n\n### 收获共鸣\n我对其中的一句话特别有感触：“美妙人生的关键在于你能迷上什么”。这不就是我们一生在追求并为之努力的东西吗?\n\n\n\n\n","tags":["读书"]},{"title":"从 ubuntu 到 arch","url":"/2018-05-19-arch/","content":"\n## 逃离 ubuntu 转投 arch\n起因先是 ubuntu16.04 升级到 ubuntu18.04, 结果每次开机直接进入了一个grub的　shell 界面, 系统无法启动了。第二次装了ubuntu18.04, 然后后面装了不少开发软件，再升级时，又挂了！有点来气，花了两天时间重装系统。不过，这次是换成了 arch。为啥，因为 arch 官网上介绍说它的定制性更高（更需要折腾），而且是滚动更新(What are you 弄啥咧?)。\n\n## arch 系统的 ｕ 盘安装\n记录一下，头一天的时候，我的安装方式是按照知乎某个人的推荐装的，结果好几个地方卡死了。比如联网，比如挂载。后来证明，只要熟读 arch 官网　wiki 上面的文档(武功秘籍)，基本上是不会整出一些\"奇门遁甲\"的啥\"幺蛾子\"的。前提是，一定要通读。\n\n\n## 切到 arch 的感受\n+ 速度比 ubuntu 快。天下武功，唯快不破。不知道是否因为 arch 的二进制包的安装方式，还是 安装的无关的依赖很少的缘故，在 arch 下面上网几乎不卡。即使看 youtube 视频也是非常流畅!\n+ 安装效率高。arch 下面 **sudo pacman -S smartgit**, 需要安装的依赖，直接选数字然后回车就好了。安装好快。而 ubuntu 下面安装 smartgit 的需要好几个步骤，比如你安装了 smartgit包，好需要相同的命令去找缺失的依赖包(javaxxxxxx)。还得说下使用 \"yaourt\" 去安装 **AUR** 类型的软件真的是很便利。比如 安装个 **nmap** 扫描一下主机ip和端口:\n\n```\n➜  blog git:(master) ✗ yaourt nmap\n1 extra/nmap 7.70-2 [installed]\n    Utility for network discovery and security auditing\n2 community/vulscan 2.0-2\n    A module which enhances nmap to a vulnerability scanner\n3 blackarch/autonse 20.82a6e18-1 (blackarch blackarch-automation)\n    Massive NSE (Nmap Scripting Engine) AutoSploit and AutoScanner.\n4 blackarch/brutespray 116.bd65d69-2 (blackarch blackarch-automation blackarch-cracker)\n...\n32 aur/umit 1.0-1 (67) (0.20)\n    A powerful nmap frontend.\n==> Enter n° of packages to be installed (e.g., 1 2 3 or 1-3)\n==> ---------------------------------------------------------\n==> (这里选数字然后回车就可以了)\n```\n+ 几乎所有需要的比较新的软件和开发工具都有了。而且都是命令行三两下就安装好了。比如 docker, vim，emacs, docker, git, smartgit, nodejs, npm, nvm, python(系统自带了), php, nginx, apache, mysql, mariadb, postgresql， virtualbox, tmux, zsh(这个好像是自带了), shadowsocks(这个好极了,就下个package, 再命令行启动一下，浏览器加个 proxy 扩展就直接翻出去了!)等, 而且这些软件几乎都是主流中非常新的版本！这个比较和我心意。\n\n## 小结\n1. 通过 ubuntu 迁移到 arch 的过程，中间加深了对挂载，分区，以及搭建系统的很多命令的认知。\n2. 选一个就近的源，比如清华的。\n3. 没有什么是不能用一条命令解决不了的，如果不行就用两条! \n4. 安装过程中，有犯错，比如一开始略过官方 wiki 直接参照网上某个人的推荐，东看一点，细看一点，结果这个装了一半，那个流程也是一半，都出现了一些一时令人懊恼的问题。还好最后回归官网 wiki 通读，针对具体的章节细读，才顺利解决了。\n5. 安装 arch 一定要联网。最简单是直接通过命令行的 ```wifi-menu``` 调出无线 wifi　的列表，选择自己知道密码的那个 wifi, 然后输入密码。\n6. 选一个图形界面桌面，比如 xfce, 安装。\n7. 在联网的基础上，第一要务是先翻出去。道理不用多说。其他都是水到渠成了。\n8. 从 arch 系统中 安装 blackarch 非常方便。blackarch 包含大概 1900 多个黑客武器! 强大而丰富的武器库！我去扒了一下，貌似 blackarch 还是 kali 系统的那个团队搞的!\n9. 然后，能用命令行快速解决的，就不要多花时间去选个图标了。比如一开视频，发现，播放没有声音! 装个 alsamixer　即可, 命令行里面直接调起 alsamixer, 控制音量啥的，都在里面了。弄张图吧。\n![](/images/full.jpg)\n","tags":["arch"]},{"title":"php 源码 (string)","url":"/2018-05-01-php-source-code-appreciation/","content":"\n# PHP 源码赏析 ~ 第一套广播体操(string 篇)\n\n## 寻根究底\n\n最近看到一些 php 的函数时，一直在想，它背后是怎么实现的呢？不仔细的挖一遍它的底细，压根就是经常会用错。而且感觉用的是一个黑箱子。指不定里面啥时候窜出一条蛇来。所以，找来源码，推敲一下底层的实现逻辑。\n<!--more-->\n\n## 第一节: 伸展运动 [strpos](https://github.com/php/php-src/blob/master/ext/standard/string.c) \n\n它的整个实现风貌先展现出来， 长的是貌美如花: \n\n### strpos 源码\n\n```\nPHP_FUNCTION(strpos)\n{\n\tzval *needle;\n\tzend_string *haystack;\n\tchar *found = NULL;\n\tchar  needle_char[2];\n\tzend_long  offset = 0;\n\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tZ_PARAM_STR(haystack)\n\t\tZ_PARAM_ZVAL(needle)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(offset)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (offset < 0) {\n\t\toffset += (zend_long)ZSTR_LEN(haystack);\n\t}\n\tif (offset < 0 || (size_t)offset > ZSTR_LEN(haystack)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Offset not contained in string\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (Z_TYPE_P(needle) == IS_STRING) {\n\t\tif (!Z_STRLEN_P(needle)) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Empty needle\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfound = (char*)php_memnstr(ZSTR_VAL(haystack) + offset,\n\t\t\t                Z_STRVAL_P(needle),\n\t\t\t                Z_STRLEN_P(needle),\n\t\t\t                ZSTR_VAL(haystack) + ZSTR_LEN(haystack));\n\t} else {\n\t\tif (php_needle_char(needle, needle_char) != SUCCESS) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tneedle_char[1] = 0;\n\n\t\tfound = (char*)php_memnstr(ZSTR_VAL(haystack) + offset,\n\t\t\t\t\t\t\tneedle_char,\n\t\t\t\t\t\t\t1,\n\t\t                    ZSTR_VAL(haystack) + ZSTR_LEN(haystack));\n\t}\n\n\tif (found) {\n\t\tRETURN_LONG(found - ZSTR_VAL(haystack));\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n```\n\n### 初探\n咋看，果然没有让我失望, 有点蒙: 这都啥啥啥? 第一眼只看懂了 if, else。 没系统的学习过 c 语言，阅读起来真的很费眼力劲, 呵呵。\n那就先过一遍: \n\n```\n\tzval *needle;\n\tzend_string *haystack;\n\tchar *found = NULL;\n\tchar  needle_char[2];\n\tzend_long  offset = 0;\n```\n这一堆，是定义了一些变量。\n\n然后\n```\n\tZEND_PARSE_PARAMETERS_START(2, 3)\n\t\tZ_PARAM_STR(haystack)\n\t\tZ_PARAM_ZVAL(needle)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_LONG(offset)\n\tZEND_PARSE_PARAMETERS_END();\n```\n没看懂，应该是初始化参数, (2, 3)说明是这个 **strpos** 函数的参数在 2 - 3 个之间。\n\n接着，进行至第三个参数 offset 的判断了。\n\n```\n\tif (offset < 0) {\n\t\toffset += (zend_long)ZSTR_LEN(haystack);\n\t}\n\tif (offset < 0 || (size_t)offset > ZSTR_LEN(haystack)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Offset not contained in string\");\n\t\tRETURN_FALSE;\n\t}\n```\n\n猜测当第三个参数 offset 是负数的时候，是反向的查找的。如果负数太小了，比如反向查找 'test' 中的 's' 来说， 就是 strpos('test', 't', -10), 就会报错了。 \n\n```\n➜   php -r \"echo strpos('test', 's', -10);\"\nPHP Warning:  strpos(): Offset not contained in string in Command line code on line 1\n\nWarning: strpos(): Offset not contained in string in Command line code on line 1\n```\n\n果然。\n\n先不追究细节, 走着。\n\n```\n\tif (Z_TYPE_P(needle) == IS_STRING) {\n\t\tif (!Z_STRLEN_P(needle)) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Empty needle\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfound = (char*)php_memnstr(ZSTR_VAL(haystack) + offset,\n\t\t\t                Z_STRVAL_P(needle),\n\t\t\t                Z_STRLEN_P(needle),\n\t\t\t                ZSTR_VAL(haystack) + ZSTR_LEN(haystack));\n\t} else {\n\t\tif (php_needle_char(needle, needle_char) != SUCCESS) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tneedle_char[1] = 0;\n\n\t\tfound = (char*)php_memnstr(ZSTR_VAL(haystack) + offset,\n\t\t\t\t\t\t\tneedle_char,\n\t\t\t\t\t\t\t1,\n\t\t                    ZSTR_VAL(haystack) + ZSTR_LEN(haystack));\n\t}\n```\n\n一个 if(){} else{}, 哎呀，我滴亲娘啊，好像很简单啊，就判断一下要查找的参数 needle 是不是字符串类型, 然后如此如此, 最后返回一个 found。\n\n而 found 最核心的就是一个真正查找这个字符的位置的函数 **php_memnstr**, 这个函数的实体实际是 **zend_memnstr** 这个函数。\n\n继续追下去看看\n\n\n```\nstatic zend_always_inline const char *\nzend_memnstr(const char *haystack, const char *needle, size_t needle_len, const char *end)\n{\n\tconst char *p = haystack;\n\tconst char ne = needle[needle_len-1];\n\tptrdiff_t off_p; \n\tsize_t off_s;\n\n\tif (needle_len == 1) {\n\t\treturn (const char *)memchr(p, *needle, (end-p));\n\t}\n\n\toff_p = end - haystack;\n\toff_s = (off_p > 0) ? (size_t)off_p : 0;\n\n\tif (needle_len > off_s) {\n\t\treturn NULL;\n\t}\n\n\tif (EXPECTED(off_s < 1024 || needle_len < 9)) {\t/* glibc memchr is faster when needle is too short */\n\t\tend -= needle_len;\n\n\t\twhile (p <= end) {\n\t\t\tif ((p = (const char *)memchr(p, *needle, (end-p+1))) && ne == p[needle_len-1]) {\n\t\t\t\tif (!memcmp(needle, p, needle_len-1)) {\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tp++;\n\t\t}\n\n\t\treturn NULL;\n\t} else {\n\t\treturn zend_memnstr_ex(haystack, needle, needle_len, end);\n\t}\n}\n```\n\n这里 zend_memnstr() , 接收四个传进来的参数。 这里可以看到， 当判断出查找的字符串很短，查找的区间也很短时，(为啥是off_s < 1024 或者 needle_len < 9 这两个阀值， 不得而知) 调用的是 glibc 库，这个库是 linux 最底层的 api, 否则就跑去调用 **zend_operators.h** 文件下面的 **ZEND_FASTCALL** 类型的 **zend_memnstr_ex**, 注释里说 glibc 更快。\n\nptrdiff_t  这个其实是一个 zend_long 在/intl/collator/collator_sort.c文件下面有这个定义。\n\n```\n#if !defined(HAVE_PTRDIFF_T) && !defined(_PTRDIFF_T_DEFINED)\ntypedef zend_long ptrdiff_t;\n#endif\n```\n\n又跳去搞事情了\n\n/ext/standard/file.c\n\n```\n#define FPUTCSV_FLD_CHK(c) memchr(ZSTR_VAL(field_str), c, ZSTR_LEN(field_str))\n\n```\n\n\n其他看不太明白。\n\n在非字符串类型搜索分支判断里面，还进行了详细的判断。总之: 要搜索的字符应该是字符串或者数值类型。\n\n\n```\nstatic int php_needle_char(zval *needle, char *target)\n{\n\tswitch (Z_TYPE_P(needle)) {\n\t\tcase IS_LONG:\n\t\t\t*target = (char)Z_LVAL_P(needle);\n\t\t\treturn SUCCESS;\n\t\tcase IS_NULL:\n\t\tcase IS_FALSE:\n\t\t\t*target = '\\0';\n\t\t\treturn SUCCESS;\n\t\tcase IS_TRUE:\n\t\t\t*target = '\\1';\n\t\t\treturn SUCCESS;\n\t\tcase IS_DOUBLE:\n\t\t\t*target = (char)(int)Z_DVAL_P(needle);\n\t\t\treturn SUCCESS;\n\t\tcase IS_OBJECT:\n\t\t\t*target = (char) zval_get_long(needle);\n\t\t\treturn SUCCESS;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL, E_WARNING, \"needle is not a string or an integer\");\n\t\t\treturn FAILURE;\n\t}\n}\n```\n\n\n然后就看到世界的尽头： \n\n```\n\tif (found) {\n\t\tRETURN_LONG(found - ZSTR_VAL(haystack));\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n```\n\n找到了, 就返回一个位置，没找到就返回 FALSE 了。\n伸展运动就做完了。\n现在回过头来看，好像没那么简单。好多个宏不知道是干啥用的， 还有几个方法。\n\n### 细究\n第一个需要搞明白的是 ZSTR_LEN(haystack) 这个宏是干啥用的。  在 zend_string.h 中找到了它的定义： \n\n```c\n#define ZSTR_VAL(zstr)  (zstr)->val\n#define ZSTR_LEN(zstr)  (zstr)->len\n#define ZSTR_H(zstr)    (zstr)->h\n#define ZSTR_HASH(zstr) zend_string_hash_val(zstr)\n```\n\n这个解释在一篇 PHP 字符扩展的[文章](https://juejin.im/entry/583e8f36ac502e006c3605ee)里面有写道：\n\" **ZSTR_** 开头的宏方法是 **zend_string** 结构专属的方法 **ZSTR_VAL**, **ZSTR_LEN**, **ZSTR_H** 宏方法分别对应 ** zend_string** 结构的成员。\n**ZSTR_HASH** 是获取字符串的hash值，如果不存在，就调用 hash 函数生成一个\"。\n\n \n## strpos 的实现思路\n\n## 小结\n头疼\n## 有木有启发?\n木有，感觉 底层写的很难懂。因为中间总是卡住。各种宏定义, 各种指针子子孙孙无穷尽也。\n\n<!--more-->\n","tags":["php"]},{"title":"php 源码 (宏)","url":"/2018-05-01-php-source-code-basic-string/","content":"\n## zend 基础类型- 宏\n\nzend 底层有相当多的宏, 特别是 php7 系列, 源码比 php 5 有不少结构方面的改变。所以不去研究 php5 的 zend 了, 直接往后研究的源码都主要看最新的 **php-src**。 zend 系列的宏主要分布在 zend_API.h, zend_types.h, zend_operators.h 里面。\n<!--more-->\n\n```\ntypedef struct _zend_object_handlers zend_object_handlers;\ntypedef struct _zend_class_entry     zend_class_entry;\ntypedef union  _zend_function        zend_function;\ntypedef struct _zend_execute_data    zend_execute_data;\n\ntypedef struct _zval_struct     zval;\n\ntypedef struct _zend_refcounted zend_refcounted;\ntypedef struct _zend_string     zend_string;\ntypedef struct _zend_array      zend_array;\ntypedef struct _zend_object     zend_object;\ntypedef struct _zend_resource   zend_resource;\ntypedef struct _zend_reference  zend_reference;\ntypedef struct _zend_ast_ref    zend_ast_ref;\ntypedef struct _zend_ast        zend_ast;\n```\n\n放眼望去，似曾相识燕归来！ \n\n### zval \nzval 不就是大名鼎鼎的 php 变量容器么！源码内使用频率相当高。一搜 php-src，超过 9999 次现身!\n可想而知， zval 肯定是灰常重要的。 \n解开这个结构体，发现是这个模样:\n\n```\nstruct _zval_struct {\n\tzend_value        value;\t\t\t/* value */\n\tunion {\n\t\tstruct {\n\t\t\tZEND_ENDIAN_LOHI_4(\n\t\t\t\tzend_uchar    type,\t\t\t/* active type */\n\t\t\t\tzend_uchar    type_flags,\n\t\t\t\tzend_uchar    const_flags,\n\t\t\t\tzend_uchar    reserved)\t    /* call info for EX(This) */\n\t\t} v;\n\t\tuint32_t type_info;\n\t} u1;\n\tunion {\n\t\tuint32_t     next;                 /* hash collision chain */\n\t\tuint32_t     cache_slot;           /* literal cache slot */\n\t\tuint32_t     lineno;               /* line number (for ast nodes) */\n\t\tuint32_t     num_args;             /* arguments number for EX(This) */\n\t\tuint32_t     fe_pos;               /* foreach position */\n\t\tuint32_t     fe_iter_idx;          /* foreach iterator index */\n\t\tuint32_t     access_flags;         /* class constant access flags */\n\t\tuint32_t     property_guard;       /* single property guard */\n\t\tuint32_t     extra;                /* not further specified */\n\t} u2;\n};\n```\n\n分为三个部分， zend_value, u1, u2 三个联合体。\n跟踪 zend_value 看看, \n\n```\ntypedef union _zend_value {\n\tzend_long         lval;\t\t\t\t/* long value */\n\tdouble            dval;\t\t\t\t/* double value */\n\tzend_refcounted  *counted;\n\tzend_string      *str;\n\tzend_array       *arr;\n\tzend_object      *obj;\n\tzend_resource    *res;\n\tzend_reference   *ref;\n\tzend_ast_ref     *ast;\n\tzval             *zv;\n\tvoid             *ptr;\n\tzend_class_entry *ce;\n\tzend_function    *func;\n\tstruct {\n\t\tuint32_t w1;\n\t\tuint32_t w2;\n\t} ww;\n} zend_value;\n```\n\n跋山涉水， zend_value 这个联合体可以存放所有可能的 php 数据类型数据。 数值分: 长整型或者双精度浮点型。 剩下的基本是指针值。有计数器指针，字符串指针，数组指针，对象指针，资源指针，引用指针, 空指针， 类指针，函数指针。 \n\n而 u1 里面又是啥东东？ ZEND_ENDIAN_LOHI_4()这个东西, \n\n```\n#ifdef WORDS_BIGENDIAN\n# define ZEND_ENDIAN_LOHI(lo, hi)          hi; lo;\n# define ZEND_ENDIAN_LOHI_3(lo, mi, hi)    hi; mi; lo;\n# define ZEND_ENDIAN_LOHI_4(a, b, c, d)    d; c; b; a;\n# define ZEND_ENDIAN_LOHI_C(lo, hi)        hi, lo\n# define ZEND_ENDIAN_LOHI_C_3(lo, mi, hi)  hi, mi, lo,\n# define ZEND_ENDIAN_LOHI_C_4(a, b, c, d)  d, c, b, a\n#else\n# define ZEND_ENDIAN_LOHI(lo, hi)          lo; hi;\n# define ZEND_ENDIAN_LOHI_3(lo, mi, hi)    lo; mi; hi;\n# define ZEND_ENDIAN_LOHI_4(a, b, c, d)    a; b; c; d;\n# define ZEND_ENDIAN_LOHI_C(lo, hi)        lo, hi\n# define ZEND_ENDIAN_LOHI_C_3(lo, mi, hi)  lo, mi, hi,\n# define ZEND_ENDIAN_LOHI_C_4(a, b, c, d)  a, b, c, d\n#endif\n```\n\n这些 哆瑞咪发嗦啦奇多, 暂时不知道做什么。不过 type, type_flags, const_flags, reserved 按照字面意思应该包含激活的类型，类型标志，常量标记，保留值。所以 u1 其实是存的类型相关的信息值。\n\nu2 里面是存放一个额外的数据, 有介绍说是一般情况下用不到？这个[博客](http://nikic.github.io/)说的。\n\n\n\n这里面有几个疑问仍未确定: \n1. zend_ast_ref 是类型数据？ \n2. 又有一个 zval! 这个是为什么？ 这个效果是不是这样： 我这个值里面还可以放任何类型的数据！php 就是这样实现存放数据的么？\n3. php 官方文档给出的是基本类型是 Boolean 布尔类型， Integer整型，Float 浮点型，String 字符串，Array 数组，Object 对象，Resource 资源类型，NULL, CallBack/Callable类型。\n4. ww 这个结构体是干啥用的？莫非是存放 CallBack/Callable 类型的数据？\n\n\n## 小结 \nPHP 底层没有看起来的那么简单。有些构造可能是巧妙的，但是目前还领会不到。\n\n<!--more-->\n","tags":["php"]},{"title":"源码","url":"/2018-05-01-tools/","content":"\n## 源码看累了\n\n源码看着看着，会产生一种疑惑： 我为什么要看源码？当初我之所以到底层看源码，完全是好奇，想知道它后面运行的机制。但是，最近开始疲劳了。忽然觉得：这样是不是没什么必要？因为，一个好的赛车手，未必就能造车，或者修车。但他可以将车玩的很溜, 上演速度与激情！而一个造车师傅，或者修车师傅，却不一定能在 F1 赛道上撒的开。\n那么，如果满足了好奇心之后，还有必要去深究底层的实现逻辑么？\n","tags":["php"]},{"title":"lua","url":"/2018-04-26-lua-lumen/","content":"\n## Lua 入门\n\n最近想系统花几天时间学习 Lua 是因为在看 《redis 实战》的过程中发现 Lua 可与 redis 匹配产生叠加性能。nginx+Lua+redis 的联姻又可以再次增强 redis 的功力。\n\n### 教程\n\n  Lua 是用标准 C 语言编写的强大的、开源、轻量级、嵌入式的脚本语言。提供面向过程, 面向对象, 面向函数式, 数据驱动的编程方式。\n\n### 设计目的\n\n  嵌入到应用程序中, 为应用程序提供灵活的扩展和定制功能。\n\n### 特性\n\n  - 轻量级: 使用标准 C 语言编写并以源码形式开放, 编译后只有 100 多k, 非常便于嵌入到别的程序中。\n  - 可扩展: Lua 提供了非常易于使用的扩展接口和机制: 由宿主(通常是 C 或 C++)提供这些功能， 使用起来就像内置的功能一般。\n  - 其他特性: 自动内存管理; 提供了一种通用的类型的表(**table**), 用来实现数组, 哈希表, 集合, 对象; 语言内置模式匹配; 闭包(**closure**); 函数也可以看作一个值; 提供多线程等。\n\n### 应用场景\n\n  - 游戏开发\n  - 独立应用脚本\n  - Web 应用脚本\n  - 扩展和数据库插件: MySQL Proxy 和 MySQL WorkBench\n  - 安全系统, 如入侵检测系统\n\n### 安装\n\n  ```bash\n  cd ~\n  curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz\n  tar zxf lua-5.3.0.tar.gz\n  cd lua-5.3.0\n  make linux test\n  make install\n  ```\n\n### 开始 \n\n```bash\n➜  ~ lua -i\nLua 5.2.3  Copyright (C) 1994-2013 Lua.org, PUC-Rio\n> print(\"Hello Lua!\")\nHello Lua!\n> \n```\n并没有诸如 **exit** 的命令退出! 直接 Ctrl + c, 呵。\n\n### First Blood Demo !\n\n``` bash\n➜ touch first-blood.lua\n➜ lua echo 'print(\"hello world lua!\")' > first-blood.lua\necho print(\"hello world lua\") > first-blood.lua\n➜  lua lua first-blood.lua \nhello world lua!\n```\n\n### 两种注释方式\n\n```bash\n-- single line commentary for lua\n--[[\nprint('multiple')\nprint('commentary')\n]]--\n```\n\n### 八种数据类型\n\n+ nil \n+ boolean\n+ number, 双精度类型浮点实数\n+ string \n+ userdata, 表示任意存储在变量中的 C 数据结构\n+ function, 由C 或者 Lua 写的函数\n+ thread, 表示执行的独立线路, 用于执行协同程序\n+ table, Lua 中的表(table), 其实是个**关联数组**(associative arrays), 数组的索引可以是数字或者字符串。使用**{}**来构造创建。\n\n### 基本\n\n+ **数字**, **字母** 和 **下划线** 构成合法变量, **区分大小写**。\n+ 默认变量都是全局的, 使用 **local** 显示声明局部变量。使用前无需声明，默认值是 **nil**, 删除一个变量直接将该变量值致 **nil** 即可。\n+ 字符串连接使用 **..** 。\n+ **#** 计算字符串长度。\n+ 索引从 **1** 开始!\n+ **table** 长度不固定, 添加新数据时长度自动增长。未初始化值为 **nil**。\n+ **线程** VS **协程**: 线程可以同时运行多个，协程任意时刻只能运行一个，并且出于运行状态的协程只有被挂起(**suspend**)时才会暂停。\n+ table 的索引可以使用**[i]**或者 **.** 操作, 如: table1[\"fix\"], table.fix。\n+ **^** 和 **..** 是右连接, 其他运算符是左连。\n\n### 循环控制\n\n+ for 循环\n+ while\n+ repeat ... until\n+ break, 跳出当前循环语句, 并执行脚本紧接着的语句。\n\n### 函数\n\n- Lua 函数可以 **return** 多个结果值。\n- Lua 函数可以在参数列表中使用 **...** 作为可变参数。\n- 函数可以作为参数传递给函数, 有点像 **Lisp** 里面的。\n\n### 运算 \n\n  + 加减乘除求余之外, 特殊的运算符号 **^** 乘幂;\n  + 关系运算符号中 **~=** 表示不等于; \n  + 逻辑运算符号三板斧: and, or , not;\n  + **..** 号连接, **#** 一元运算符, 返回字符串或表的长度(pirnt(#'abc'))。\n  + 运算符优先级排行榜:\n\n  ```\n  ^\n  not - (unary)\n  * /\n  + -\n  ..\n  < > <= >= ~= ==\n  and \n  or\n  ```\n\n## 参考来源\n+ [Lua官网](https://www.Lua.org/)\n+ [Lua 基本入门网上教程](http://www.runoob.com/Lua/Lua-tutorial.html)\n+ [github 源码](https://github.com/lua/lua)\n+ [Lua wiki tools](http://lua-users.org/wiki/)\n","tags":["lua"]},{"title":"update ubuntu16.04 to ubuntu18.04","url":"/2018-04-24-update-ubuntu2LTS18.04/","content":"\n```\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install update-manager-core\nsudo do-release-upgrade -d --devel-release\n```\n","tags":["点滴"]},{"title":"Golang way","url":"/2018-03-01-TheWayToGoLang/","content":"# Go 入门\n\n  一直听说 Go 是天生支持并发编程的, 于是磨刀霍霍向牛羊, 入坑。\n\n### 开始\n\n#### 特点\n\n  - Go 语言可以进行隐式定义, 但是不存在隐式类型转换。\n  - 所有的内存在 Go 中都经过初始化的。\n  - 变量的命名使用陀峰法，首个单词小写，每个新单词首字母大写。如果需要全局变量能够被外包所使用， 则首字母也需要大写。\n\n#### 基本类型和运算符\n+ 两个类型相同的值可以使用 **==** 或者 **!=** 来比较。不同类型的值不可以比较。\n+ Go 支持 整形和浮点型数字, 并且原生支持复数, 其中位的运算采用补码。int 是最快的类型, 尽量使用 float64。\n+  * 号和指针名称间留有一个空格，以防止被误认为是乘法表达式。 * 用在一个指针前面时，将得到这个指针指向地址所存储的值；这就是反引用(间接引用)操作符, 也可以称为指针转移。指针的高级应用是可以传递一个变量的应用(如函数的参数), 如此不会传递变量的拷贝。注意: 在 Go 中不允许像 C 中的 *pointer++ 的指针算法。\n+  特殊的流程控制, **select** 结构用于 **channel** 的选择。可省掉判断条件里面的小括号。必要时使用小括号提高优先级。 **switch** 可以接受的 **case** 判断可以是统一类型的任何类型的值或者表达式。而 **for** 可以在循环体内同时使用多个计数器。\n\n#### 精华的 goroutine 和  channel\n**goroutine** 是 Go 程序并发的执行体, **channel** 是它们之间的连接, 是可以让一个 goroutine 发送特征值到另一个 goroutine 的通信机制．没一个 channel 是一个具体类型的导管，叫做通道的元素类型．channel 的创建使用 make. channel 有两个操作, send, receive 统称通信．使用上古神奇的符号 **<-**．close(ch) 关闭　channel, make()可以创建两种通道, 带正数的第二个参数的是缓冲通道，其他的是非缓冲通道.\n\n## 参考来源 \n + [Go之路](https://github.com/Unknwon/the-way-to-go_ZH_CN)\n + [Go官网](https://golang.org/)\n","tags":["go"]},{"title":"过去的 2017","url":"/2018-01-14-theEndOf2017/","content":"\n## 2017年小结\n之前元旦前的一天本来想做个小结的，后来因为工作变动，加上适应新的环境，就拖了一阵．\n<!--more-->\n\n## 时间花销\n2017 年在上班工作区间的时间利用有所提升，特别是有半年的时间基本上都是围绕在上午, 集中精力将当天的主要编码任务完成．从上半年的一到公司优先刷知乎，刷 News 有了一些习惯上面的转变．所以加班很少，有了更多的时间上研究自己感兴趣的东西, 这也为目前所从事的工作打下了一个基础．\n\n但是, 从上下班路上的时间，以及周末等非上班时间的利用. 并不充分．特别是可以到墙外，所以经常看 Youtube 上的视频, 看了不少电影，连续剧，课程，音乐, 还有个别综艺节目. 整个 2017 年下来，英语听力,阅读水平有所提升，口语 0 提升.\n\nEmacs 中的 Org-mode 工作日志基本上只看到了工作场合下的时间分布，而且极其粗略．事情轻重缓急层次偶尔还没有归档．\n\n## 目标完成情况\n+ DONE [#A]游泳卡一共充了两次 500 RMB 全部用光了．\n+ DONE [#B]个人博客完成一次重组(hero 静态化).\n+ DONE [#A]<<设计模式之禅>>使用 php 重构一边.\n+ IN_PROGRESS [#A]学习 docker, 拥有属于自已习惯的一套系统和开发环境\n+ IN_PROGRESS [#A]啃完一边算法导论(包含做习题)\n+ IN_PROGRESS [#B]听懂一般的音乐表达的方式《如何听懂音乐》\n+ In_progress [#B]学会六孔陶笛, 后半年12孔陶笛能正确自如的演奏自己喜欢的调子\n+ DONE [#A]学习一门新语言并使用到开发过程中来(Golang | Nodejs)(最后选择了 Golang)。\n+ TODO [#B]参加一项深圳的全程马拉松, 时间在5小时30分以内\n+ DONE [#B]学习 vue 前端框架\n+ TODO [#B]使用自己总结的股票数据去买入股票，盈利在5%以上\n+ IN_PROGRESS [#A]读十本豆瓣排名前十的书籍\n+ Question\n\n问题其实蛮多的,比如:\n\n做好的规划，执行不充分，\n专业上的投入专注度续航能力欠佳,\n偷懒或者被其他事情转移了注意力.\n平时有点子的时刻也挺多的，特别是在车上，偶尔冒出一些新的构思，或者创想, 或者是改变生活现状的火花, 只是需要作出决定的时刻没有足够的决绝!甚至有一点拖! 还有多次，想的和做的不一致! 知行不一!这就像军队没有统一的意志,所以这一年出来的效果，不过是”呵呵”二字． 这个毛病，在短时间之内，尚需徐徐图之. 否则， 2018 年里，还是受制肘.\n\n## 关于早起\n2017 年里，除了感冒期间, 过年, 以及和朋友聚会喝了一点小酒，第二天起来会稍晚一点. 这些情况加起来，差不多有10天左右是晚于８点半起来的，有差不多 340 天基本是 5:50~7:30 时间区间起来的, 终于弄了个习惯! 可以继续保持下去，早起，能保证一天的精气神!\n\n## 目标\n暂时留着 Org-mode 里面吧．留点悬念，2019 年元旦再总结. 不过, 2018 年的首要目标是还清 2017 年欠下的技术债．\n\n## 2018 的一个展望\n希望今年能遇到一个心仪的姑娘!\n\n<!--more-->\n","tags":["点滴"]},{"title":"备忘录模式","url":"/2017-12-01-mementoPattern/","content":"# 0x00 备忘录模式\n\n## 定义\n**Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later.(在不破坏封装性的前提下，捕获一个对象的内部状态，并在这个对象外保存该状态．之后可将该对象恢复到之前保存的状态．)**\n\n<!--more-->\n## 角色\n+ Originator 发起人角色, 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据．\n+ Memento 备忘录角色, 负责存储　Originator 发起人对象的内部状态，在需要的时候提供发起人需要的内部状态．\n+ Caretaker 备忘录管理员角色, 对备忘录进行管理，保存和提供备忘录.\n\n## php 实例\n```\n<?php\n/*\n * Memento Pattern\n */\n\n// 发起人\nclass Originator {\n    private $state;\n\n    public function getState()\n    {\n        return $this->state;\n    }\n\n    public function setState($_state)\n    {\n        $this->state = $_state;\n    }\n\n    // 新建备忘录\n    public function createMemento()\n    {\n        return new Memento($this->state);\n    }\n\n    // 备忘录恢复\n    public function restoreMemento(Memento $_memento)\n    {\n        $this->setState($_memento->getState());\n    }\n}\n\n// 备忘录角色\nclass Memento {\n    private $state;\n\n    public function __contruct($_state)\n    {\n        $this->state = $_state;\n    }\n\n    public function getState()\n    {\n        return $this->state;\n    }\n\n    public function setState($_state)\n    {\n        $this->state = $_state;\n    }\n}\n\n// 备忘录管理者\nclass Caretaker {\n    private $memento;\n\n    public function getMemento()\n    {\n        return $this->memento;\n    }\n\n    public function setMemento(Memento $_memento)\n    {\n        $this->memento = $_memento;\n    }\n}\n\nclass Client {\n    public static function main()\n    {\n        $originator = new Originator();\n        $caretaker = new Caretaker();\n        $caretaker->setMemento($originator->createMemento());\n        $originator->restoreMemento($caretaker->getMemento());\n    }\n}\n\n```\n# 0x01 小结\n\n## 场景\n+ 需要保存和恢复数据的相关状态场景\n+ 提供一个可回滚的操作\n+ 需要监控的副本中\n+ 数据库连接的事务管理就是用的备忘录模式．\n\n## 注意\n+ 备忘录的生命周期需要主动管理, 备忘录创建出来就要在＂最近＂的代码中使用，建立就要使用，不使用立刻删除其引用，坐等GC处理它．\n+ 不要在频繁建立备份的场景中使用备忘录模式，因为: \n  1. 控制不了备忘录创建的对象数量\n  2. 大对象的创建需要消耗资源，影响系统的性能\n\n\n<!--more-->\n","tags":["设计模式"]},{"title":"门面模式","url":"/2017-11-30-facade/","content":"\n# 0x00 门面模式\n外观模式.\n\n## 定义\n** Provide a unified interface to a set of interface in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.(要求一个子系统的外部与内部的通信必须通过一个统一的对象进行．)**\n\n## 角色\n+ Facade 门面角色, 该角色知晓所有功能和责任，委托类．\n+ Subsystem 子系统角色, 子系统并不知道门面类的存在．\n\n## 优点\n减少系统的相互依赖\n\n## 缺点\n不符合开闭原则．\n\n## 应用场景\n适用于:\n+ 为一个复杂的模块或子系统提供一个供外界访问的接口．\n+ 子系统相对独立.\n+ 预防低水平人员带来的风险扩散．\n\n## php实现\n```\n<?php\n\n// 子系统\nclass SubsystemOne {\n    public function dosthFir()\n    {\n        echo 'subsystem class one.';\n    }\n}\nclass SubsystemTwo {\n    public function dosthSec()\n    {\n        echo 'subsystem class two.';\n    }\n}\nclass SubsystemThr {\n    public function dosthThr()\n    {\n        echo 'subsystem class three.';\n    }\n}\n\n// 门面类\nclass Facade {\n    private $objOne;\n    private $objTwo;\n    private $objThree;\n    private $context;\n\n    public function __construct()\n    {\n        $this->objOne = new SubsystemOne();\n        $this->objTwo = new SubsystemTwo();\n        $this->objThr = new SubsystemThr();\n        $this->context = new Context();\n    }\n\n    public function jobFir()\n    {\n        $this->objOne->dosthFir();\n    }\n    public function jobSec()\n    {\n        $this->objTwo->dosthSec();\n    }\n    public function jobThr()\n    {\n        $this->context->combineJob();\n    }\n}\n\n// 封装类, 不要直接参与子系统内的业务逻辑\nclass Context {\n    private $objOne;\n    private $objThr;\n\n    public function __construct()\n    {\n        $this->objOne = new SubsystemOne();\n        $this->objThr = new SubsystemThr();\n    }\n\n    public function combineJob()\n    {\n        $this->objOne->doSthFir();\n        $this->objThr->doSthThr();\n    }\n}\n```\n\n# 0x01 小结\n门面不参与子系统内的业务逻辑．Laravel 框架就用了不少 Facade.\n","tags":["设计模式"]},{"title":"设计模式-观察者模式","url":"/2017-11-29-observerPattern/","content":"# 0x00 观察者模式\n也可称发布订阅模式(Publish/Subscribe).\n\n## 定义\n**Define a one-to-many dependency between objets so that when one object changes state, all its dependents are notified and updated automatically.(定义对象间一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新．)**\n<!--more-->\n\n## 角色\n+ Subject 被观察者, 必须能够动态地增加和取消观察者，起到观察观察者并通知观察者的职责.\n+ Observer 观察者, 观察者接受到消息通知后，进行更新．\n+ ConcreteSubject 具体被观察者, 定义被观察者自已的业务逻辑，同时定义对哪些事件进行通知．\n+ ConcreteObserver 具体观察者, 每个具体观察者自己的处理逻辑．\n\n## 优点\n* 抽象耦合观察者和被观察者之间的关系, 使之易于扩展．\n* 建立一套触发机制．\n\n## 缺点\n多级触发时，效率变差．\n\n## php 实现\n```\n<?php\n/*\n * observer pattern\n */\n\n//被观察者\nabstract class Subject {\n    private $observers = [];\n    public function addObserver(Observer $_observer)\n    {\n        array_push($this->observers, $_observer);\n    }\n\n    public function delObserver(Observer $_observer)\n    {\n        $key = array_search($this->observers, $_observer);\n        if ($key !== false) {\n            array_splice($this->observers, $key, 1);\n        }\n    }\n\n    // 通知所有观察者\n    public function notifyObservers()\n    {\n        foreach($this->observers as $observer) {\n            $observer->update();\n        }\n    }\n}\n\n\n// 具体被观察者\nclass ConcreteSubjects extends Subject {\n    public function doSth()\n    {\n        parent::notifyObservers();\n    }\n}\n\n// 观察者接口\ninterface Observer {\n    public function update();\n}\n\n\nclass ConcreteObserver implements Observer {\n    public function update()\n    {\n        echo \"Get it!Yes!Sir!\";\n    }\n}\n\nclass Client {\n    public static function main()\n    {\n        $subject = new ConcreteSubjects();\n        $observers = new ConcreteObserver();\n        $subject->addObserver($observers);\n        $subject->doSth();\n    }\n}\n(new Client())::main();\n```\n## 用武之地\n* 可拆分的非组合的关联行为场景.\n* 事件多级出发场景．\n* 跨系统的消息交换场景，如消息队列的处理机制．\n\n# 0x01 小结\n观察者模式需要重点解决两个问题: \n+ 广播链, 在一个观察者模式中，最多出现一个对象既是观察者也是被观察者，即消息最多转发一次(转发两次)是比较恰当的好控制的．\n+ 异步处理, 需要考虑线程安全和队列．\n\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-组合模式","url":"/2017-11-28-composite/","content":"\n# 0x00 组合模式\n组合模式，即合成模式．\n\n## 定义\n**Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.(将抽象对象组合成树形结构以表示＂部分－整天＂的层次结构，使得用户对单个对象和组合对象的使用具有一致性．)**\n\n## 关键角色\n+ Component 抽象构件, 定义参加组合对象的共有属性和方法, 可以定义一些默认的属性或行为．\n+ Leaf 叶子构件, 叶子对象，无剩余分支, 属于遍历的最小单位．\n+ Composite 树枝构件, 树枝对象，组合树枝节点和叶子节点形成一个树形结构．\n\n## 优点\n+ 高层模块调用简单, 一棵树形机构中的所有节点都是 Component, 局部和整体对调用者来说没有区别。即高层模块无需关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。\n+ 节点自由增加\n如果想增加一个树枝节点，树叶节点，只要找到它的父节点即可。容易扩展。\n\n## 缺点\n树叶和树枝直接使用了实现类，限制了接口的使用范围．\n\n## 使用场景\n+ 维护和展示\"部分-整体\"关系的场景，诸如树形菜单，文件和文件夹管理．\n+ 从一个整体中能够独立出部分模块或功能的场景．\n\n## php实现\n```\n<?php\n\n// 抽象构件\nabstract class Component {\n    public function doSth() {}\n}\n\n// 树枝构件\nclass Composite extends Component {\n    private $compArr = [];\n    public function add(Component $_component)\n    {\n        array_push($this->compArr, $_component);\n    }\n\n    public function remove(Component $_component)\n    {\n        $key = array_search($_component, $this->compArr);\n        if (!$key !== false) {\n            array_splice($this->compArr, $key, 1);\n        }\n    }\n\n    public function getChildren()\n    {\n        return $this->compArr;\n    }\n}\n\n// 叶子构件\nclass Leaf extends Component {\n    public function doSth()\n    {}\n}\n\nclass Client {\n    public static function main()\n    {\n        $root = new Composite();\n        $root->doSth();\n        $branch = new Composite();\n        $root->add($branch);\n        $leaf = new Leaf();\n        $branch->add($leaf);\n    }\n    public static function showTree(Composite $root)\n    {\n    }\n}\n\n```\n# 0x 小结\n不管你在不在, 设计方式就在那里......\n\n","tags":["设计模式"]},{"title":"设计模式-迭代器模式","url":"/2017-11-27-iterator/","content":"\n# 0x00 迭代器模式\n迭代器类似于一个数据库中(MySQL的游标是单向的)的游标，可以在一个容器内翻滚，遍历所有的查看的元素.\n\n## 定义\n**Provide a way to access the elements of an arrgegate object sequentially without exposing its underlying representation.**(它提供一种方法访问容器对象中的各个元素，而又不需暴露对象的内部细节．)\n<!--more-->\n\n## 角色\n* Iterator 抽象迭代器, 定义和遍历元素的接口, 一般有固定的三个方法: first(), next(), hasNext().\n* ConcreteIterator 具体迭代器, 具体实现迭代器接口．\n* Aggregate 抽象容器, 提供创建具体迭代器角色的接口．\n* ConcreteAggregate 具体容器, 创建迭代器的对象．\n\n## php实现\n```php\n<?php\n/*\n * Iterator Pattern\n */\ninterface IIterator {\n    public function next();\n    public function hasNext();\n    public function remove();\n}\n\nclass ConcreteIterator implements IIterator {\n    private $arr = [];\n    public $cursor = 0;\n\n    public function __construct($_arr)\n    {\n        $this->arr = $_arr;\n    }\n\n    public function hasNext()\n    {\n        return $this->cursor == count($this->arr) ? false : true;\n    }\n\n    public function next()\n    {\n        $result = null;\n        if($this->hasNext()) {\n            return ($this->arr)[$this->cursor++];\n        }\n        return $result;\n    }\n\n    // 开发系统时，如果用到迭代器的删除方法，应该完成两个功能: 1. 删除当前元素, 2. 当前游标指向下一个元素．\n    public function remove()\n    {\n        $this->cursor = null;\n        return true;\n    }\n}\n\ninterface Aggregate {\n    public function add($obj);\n    public function remove($obj);\n    public function iterator();\n}\n\nclass ConcreteAggregate implements Aggregate {\n    private $arr = [];\n\n    public function add($obj)\n    {\n        $this->arr[] = $obj;\n    }\n\n    public function iterator()\n    {\n        return new ConcreteIterator($this->arr);\n    }\n\n    public function remove($obj)\n    {\n        $this->remove($obj);\n    }\n}\n\nclass Client {\n    public static function main()\n    {\n        $agg = new ConcreteAggregate();\n        $agg->add('test');\n        $agg->add('hello');\n        $agg->add('world');\n        $iterator = $agg->iterator();\n        while ($iterator->hasNext()) {\n            echo $iterator->next(), PHP_EOL;\n        }\n    }\n}\n(new Client())::main();\n/*\ntest\nhello\nworld\n*/\n```\n## php 中自有的 Iterator 接口\n[php 原生迭代器](http://php.net/manual/en/spl.iterators.php).\n\n```php\nIterator extends Traversable {\n/* 方法 */\nabstract public mixed current ( void )\nabstract public scalar key ( void )\nabstract public void next ( void )\nabstract public void rewind ( void )\nabstract public boolean valid ( void )\n}\n```\n提供了好几个方法.\n\n# 0x01 小结\n渐渐能摸着一些门道了．\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-适配器模式","url":"/2017-11-26-adapterPattern/","content":"\n# 0x00 适配器模式\n适配器模式，也叫变压器模式, 包装模式(Wrapper)。 装饰者模式也是包装模式的一种。电流传输过程中使用的高压电流，输送到千里之外的家家户户前，并不能直接使用，否则直接烧坏了电器。这就需要进行降压，使用适配器将高压电流转变成家用电器适用的 220v(中国) 电流。\n\n## 定义\n**Convert the interface of  a class into another interface clients expect. Apdapter lets classes work togetherthat couldn't otherwise because of incompatible interfaces.**(将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。)\n\n<!--more-->\n\n## 角色\n* Target 目标角色, 期望最后提供的目标接口。存在。\n* Adaptee 源角色, 需要转变的接口。存在。\n* Adapter 适配器角色，核心角色。 \n\n## 优点\n+ 使两个没有任何关系的类在一起运行。\n+ 增加类的透明性。 \n+ 提高类的复用度。\n+ 灵活。\n\n## php实现\n\n```php\n<?php\ninterface Target {\n    public function job();\n}\n\nclass ConcreteTarget implements Target {\n    public function job() {\n        echo '220 v 电流可以正常使用' . PHP_EOL;\n    }\n}\n\nclass Adaptee {\n    public function doSth() {\n        echo '25000 V高压电流也能用' . PHP_EOL;\n    }\n}\n\nclass Adapter extends Adaptee implements Target {\n    public function job() {\n        parent::doSth();\n    }\n}\n\nclass Client {\n    public static function main() {\n        $target  = new ConcreteTarget();\n        $target->job();\n        $target2 = new Adapter();\n        $target2->job();\n    }\n}\n(new Client())::main();\n// 220 v 电流可以正常使用\n// 25000 V高压电流也能用\n\n```\n# 0x01 小结\n\n\n\n<!--more-->\n\n","tags":["设计模式"]},{"title":"设计模式-策略模式","url":"/2017-11-24-strategy/","content":"\n# 0x00 策略模式\n\n策略模式，也叫政策模式, 使用的是面向对象的继承和多态机制。\n\n## 定义\n\n** Define a amily of algorithms, encapsulate each one, and make them interchangeable**. (定义一组算法，将每个算法都封装起来，并且使它们之间可以交换。) \n\n<!--more-->\n\n## 三个角色组成\n+ Context 封装角色, 也称上下文角色，起承上启下封装作用，屏蔽高层模块对策略，算法的直接访问，封装可能存在的变化。\n+ Strategy 抽象策略角色，策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。\n+ ConcreteStrategy 具体策略角色，实现抽象策略中的操作，该类含有具体的算法。\n\n\n## 优点\n\n+ 算法可以自由切换\n只要实现了抽象策略，就成为了策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。\n+ 避免使用多重条件判断\n策略家族对外提供的访问接口就是封装类，简化操作，避免条件语句判断。\n+ 易于扩展\n\n## 缺点\n+ 策略类数量增多\n每个策略都是一个类，复用的可能性很小，类数量持续增多。\n+ 所有的策略类都需要对外暴露\n上层模块必须知道有哪些策略，才能进一步决定使用哪一个策略。\n\n## 使用场景\n\n+ 多个类只有算法或行为上略有不同的场景。\n+ 算法需要自由切换的场景。\n+ 需要屏蔽算法规则的场景。\n\n\n## PHP 实现\n\n```php\n<?php\n\n// 抽象策略接口\ninterface Strategy {\n    public function doSth();\n}\n\n// 具体策略角色\nclass ConcreteStrategy1 implements Strategy {\n    public function doSth()\n    {\n        echo 'strategy 1';\n    }\n}\n\n\nclass ConcreteStrategy2 implements Strategy {\n    public function doSth()\n    {\n        echo 'strategy 2';\n    }\n}\n\n\n// 封装角色\nclass Context {\n    private $strategy = null;\n    public function Context(Strategy $_strategy)\n    {\n        $this->strategy = $_strategy;\n    }\n\n    public function doAct()\n    {\n        $this->strategy->doSth();\n    }\n}\n\n// 场景类\nclass Client {\n    public static function main()\n    {\n        $strategy = new ConcreteStrategy1();\n        $context = new Context($strategy);\n        $context->doAct();\n    }\n}\n\n\n//调用\n(new Client())::main(); // output: strategy 1\n\n```\n\n# 0x01 小结\n类似于可以提供上、中、下对策的场景选择时，使用策略模式最佳。\n\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-装饰者模式","url":"/2017-11-23-decorator/","content":"\n# 0x00 装饰者模式\n\n## 定义\n**Attach additional responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative to subclassing for extending functionality.(动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。) **\n\n<!--more-->\n## 通用类四个角色\n+ Component 抽象组件, 作为最核心最原始的对象接口或者抽象类。\n+ ConcreteComponent 具体构件, 接口或者抽象类的实现。\n+ Decorator 装饰角色, 属性中必然有一个 private 变量指向 Component 抽象组件。\n+ 具体装饰角色\n\n## 优点 \n+ 装饰类和被装饰类可以独立发展, 而不会相互耦合。Component 类无须知道 Decorator 类, Decorator 类是从外部扩展 Component 类的功能，而 Decorator 也不需知道具体的构件。\n+ 装饰模式是继承关系的一个替代方案。\n+ 动态地扩展一个实现类的功能。\n\n## 缺点\n多层复杂的装饰, 数量增加, 会增加系统的复杂度, 同时带给排查问题的时间和难度。\n\n## php 实例\n\n```php\n\n<?php\n/*\n * decorator pattern\n */\n\nabstract class Component {\n    abstract function doSth();\n}\n\nclass ConcreteComponent extends Component {\n    public function doSth() {\n        echo 'concrete component';\n    }\n}\n\n// 抽象装饰类\nabstract class Decorator extends Component {\n    private $component = null;\n    public function Decorator(Component $_component) {\n        $this->component = $_component;\n    }\n\n    public function doSth()\n    {\n        $this->component->doSth();\n    }\n}\n\n// 具体装饰类\nclass ConcreteDecorator1 extends Decorator {\n    public function ConcreteDecorator1(Component $_component) {\n        parent::__construct($_component);\n    }\n\n    private function deco1() {\n        echo 'decorator 1 ';\n    }\n\n    public function doSth() {\n        $this->deco1();\n        parent::doSth();\n    }\n}\nclass ConcreteDecorator2 extends Decorator {\n    public function ConcreteDecorator2(Component $_component) {\n        parent::__construct($_component);\n    }\n\n    private function deco2() {\n        echo 'decorator 2 ';\n    }\n\n    public function doSth() {\n        $this->deco2();\n        parent::doSth();\n    }\n}\n\n\n$component = new ConcreteComponent();\n$component = new ConcreteDecorator1($component);\n$component = new ConcreteDecorator2($component);\necho $component->doSth();\n\n// decorator 2 decorator 1 concrete component\n\n```\n\n# 0x01 小结\n\n优点和缺点是并存的，优点有时候也会转化成缺点。反之，亦然。 \n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-责任链模式","url":"/2017-11-22-chainOfResponsibility/","content":"\n# 0x00 责任链模式\n\n## 定义\n**Avoid coupling the sender of a request to its rceiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.(使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。)**\n\n<!--more-->\n\n## 重点\n其重心和核心都在“链”上，有一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果，多个具体处理者 ConcreteHandler 组成了责任者模式的核心\"链\"。\n\n## 优点\n将请求和处理分开。请求者只需递交请求到窗口，不关心谁在处理，而处理者只关心自己的处理部分，然后提交下一级处理者，直至结束。灵活解耦。\n\n## 缺点\n+ 性能, 每个请求从链头遍历到链尾, 当链较长时，性能会有问题。\n+ 调试，这个是否只能二分断点排查了。。。。。。\n\n## 留意\n对链的节点数量进行限制，避免超长链的现象发生。可在 setNext()方法中判断\n\n## php 实现\n\n```\n<?php\nabstract class Handler {\n    private  $nextHandler;\n    public final function job(Request $_request) {\n        $reponse = null;\n        if ($this->getEmerLevel() == $_request->getRequestLevel()) {\n            $response = $this->report($_request);\n        } else {\n            if ($this->nextHandler != null) {\n                $response = $this->nextHandler->job($_request);\n            }\n        }\n        return $response;\n    }\n\n    public function setNext(Handler $_handler) {\n        $this->nextHandler = $_handler;\n    }\n\n    // 处理紧急程度\n    abstract function getEmerLevel();\n\n    // 处理任务\n    abstract function report();\n}\n\nclass Level {\n\n}\n\nclass Request  {\n    public function getRequestLevel() {\n        return null;\n    }\n}\n\nclass Response {\n\n}\n\n// 三个具体处理者\nclass ConcreteHandler1 extends Handler {\n    protected function report(Request $_request) {\n        return null;\n    }\n\n    protected function getEmerLevel() {\n        return null;\n    }\n}\n\nclass ConcreteHandler2 extends Handler {\n    protected function report(Request $_request) {\n        return null;\n}\n\n    protected function getEmerLevel() {\n        return null;\n    }\n}\nclass ConcreteHandler3 extends Handler {\n    protected function report(Request $_request) {\n        return null;\n    }\n    protected function getEmerLevel() {\n        return null;\n    }\n}\n\n// 场景类\nclass Client {\n    public static function main() {\n        $handler1 = new ConcreteHandler1();\n        $handler2 = new ConcreteHandler2();\n        $handler3 = new ConcreteHandler3();\n        $handler1->setNext($handler2);\n        $handler2->setNext($handler3);\n        $res = $handler1->job(new Request());\n    }\n}\n```\n# 0x01 小结\n在责任者模式的核心是: 发起的一个请求直接投给第一个处理者, 依次传递给下一层处理者，直至最终返回结构, 整个请求的处理过程被屏蔽起来。\n\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-命令模式","url":"/2017-11-21-command/","content":"\n# 0x00 命令模式\n\n## 定义\n\n**命令模式是一个高内聚的模式，其定义为: Encapsulate a request as an object, there by letting you parameterize clients with different requests, queue or log requests, and support undoable oerations.**\n(将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求队列或者记录请求日志，可以提供命令的撤销和回复功能。)\n\n## 通用类\n\n包含三个角色: \n+ Receive 接受这角色, 命令传递到这里被执行。\n+ Command 命令角色, 声明需要执行的所有命令。\n+ Invoker 调用者角色, 接受到命令，并执行命令。\n\n## php 实现\n\n```\n<?php\n/*\n  command pattern\n */\n\n// 通用的 Receiver 类\nabstract class Receiver {\n    abstract function dosth();\n}\n\n// 具体的 Receiver 类\nclass ConcreteReceiver1 extends Receiver  {\n    public function doSth() {\n    }\n}\n\nclass ConcreteReceiver2 extends Receiver {\n    public function doSth() {\n\n    }\n}\n\n// 抽象的Command 类\nabstract class Command {\n    abstract function execute();\n}\n\n// 具体 Command 类\nclass ConcreteCommand1 extends Command {\n    private $receiver;\n\n    public function ConcreteCommand1(Receiver $_receiver) {\n        $this->receiver = $_receiver;\n    }\n\n    public function execute() {\n        $this->receiver->doSth();\n    }\n}\n\nclass ConcreteCommand2 extends Command {\n    private $receiver;\n\n    public function ConcreteCommand2(Receiver $_receiver) {\n        $this->receiver = $_receiver;\n    }\n\n    public function execute() {\n        $this->receiver->doSth();\n    }\n}\n\n// 调用者 Invoker 类\nclass Invoker {\n    private $command;\n\n    public function setCommand(Command $_command) {\n        $this->command = $_command;\n    }\n    public function act() {\n        $this->command->execute();\n    }\n}\n\n// 场景调用\nclass client {\n    public static function main() {\n        $invoker = new Invoker();\n        $receiver = new ConcreteReceiver1();\n        $command = new ConcreteCommand1($receiver);\n        $invoker->setCommand($command);\n        $invoker->act();\n    }\n}\n```\n\n# 0x01 小结\n切勿好高骛远, 即使你的征途是星辰大海, 也要脚踏实地做好准备工作。\n","tags":["设计模式"]},{"title":"中介者模式","url":"/2017-11-12-MediaPattern/","content":"\n# 0x00 中介者模式\n现实生活中像神舟飞船的指挥中心, 机场的调度中心, MVC 框架中的 C(controller), 媒体网关, 房租中介等等, 都有着中介者的影子．中介者模式还叫 **调停者模式** ．\n\n## 定义\n*Define an boject that encapsulates how a set of objects nteract. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.(用一个中介对象封装一系列的对象交互，中介者是各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互．)*\n\n## 构成\n+ Mediator 抽象中介者角色, 抽象中介者角色定义统一的接口，用于各同事角色之间的通信．\n+ Concrete Mediator 具体中介者角色, 具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于同事角色．\n+ Colleague 同事角色, 每个同事角色与其他的同事角色的通信, 必须经过\"和事老\"**中介者**协作．每个同事类的行为分为两种: \n 1. 自发行为: 同事本身的行为, 如改变对象自身的状态, 处理自己的行为等不需要依赖中介者的动作．\n 2. 依赖方法: 依赖中介者才能完成的行为．\n\n## 优点 \n中介者模式减少了类之间的依赖，同事类只依赖于中介者, 将**一对多**的依赖变成**一对一**的依赖，减少依赖的同时也降低了类之间的耦合．\n\n## 缺点\n随着逻辑复杂度增加，原本 N　个对象直接的相互依赖关系转嫁给中介者和同事类的依赖关系，中介者的逻辑会逐渐复杂，并且变得越来越庞大臃肿．\n\n## 使用场景\n多个对象之间**紧密耦合**(在类图中出现了蜘蛛网状结构)的情况下，用中介者是好的选择．\n话说那些什么经纪人什么秘书的是不是中介者模式？\n\n## php 实现\n```\n<?php\n\n// 通用抽象中介者\nabstract class Mediator {\n    protected  $colleague;\n\n    public function getColleague() {\n        return $this->colleague;\n    }\n\n    public function setColleague(ConcreteColleague $conColl) {\n        $this->colleague = $conColl;\n    }\n\n    abstract public function doSth();\n}\n\n// 通用中介者\nclass ConcreteMediator extends  Mediator {\n    public function dosth() {}\n}\n\n// 抽象同事类\nabstract class Colleague {\n    protected $mediator;\n\n    public function Colleague(Mediator $_mediator) {\n        $this->mediator = $_mediator;\n    }\n}\n\n// 具体同事类\nclass ConcreteColleague extends Colleague {\n    public function ConcreteColleague(Mediator $_mediator) {\n        parent::setColleague($_mediator);\n    }\n\n    // 自发行为\n    public function selfMethod() {}\n\n    // 依赖方法\n    public function relyMethod() {\n        parent::doSth(); // 委托中介处理\n    }\n}\n?>\n```\n\n# 小结 \n字面上中介和代理多少带着模糊的雷同，所以中介和代理的区别是？\n","tags":["设计模式"]},{"title":"秒杀场景小结","url":"/2017-11-08-secKill/","content":"\n即使看过秒杀场景的处理办法，还是会忘，因为没有真正实战过．总得抽时间总结一下这个场景的应对策略．那天就需要处理这块业务呢？以防一般的 bug 在那时顶风作案.\n\n## 0x00 那山，那人，那秒杀\n<!--more-->\n秒杀场景通常发生在活动日, 节假日促销，\"双十一\", 春运火车票抢购等. 此时,　一般是月黑风高, Bug 容易趁机做乱之时．\n\n<!-- 但是根本上, bug能顶风作案的 -->\n\n秒杀开始之前，先来欣赏一段<<亮剑>>李云龙攻打县城的场景, 当时日方从四面八方往平安县城增援时, 丁伟所在的防区的阻击方式很是巧妙: \n\n一开始没搞懂增援的敌人是干啥时, 丁伟的策略是: \"一线部队放过敌人的骑兵, 全力阻击敌人的步兵， 二线部队务将敌人的骑兵拦截在二道河口\".　然后发现敌人不顾一切地要奔赴县城时，他明白了，这伙部队是下了死命令往县城奔啊！如果硬抗，肯定是伤亡惨重啊，但是又不能撤出部队，让敌军从防区里过去．亮点来了, 下了四道命令: \n\n1. 发动地方武装和民兵, 沿公路线及公路两侧埋设地雷, 密度要大;\n2. 派出小部队，占据公路沿线的隘口和制高点, 节节抗击．迟缓敌人的进攻锋芒;\n3. 炸毁防区内所有的桥梁;\n4. 前沿部队撤出阵地，让开路口，让敌人进来．采用麻雀战，袭扰敌人．\n\n\"原则就只有一个，不惜一切代价，阻敌增援.\"\n \n 这不就是活生生的秒杀现场吗！下单的人就是\"日军\"，不顾死活的都狂点狂刷剩下的库存, 提交表单, 奔赴\"县城(数据库)\"! 买!买!买!但是你说我网站能让你轻易从我\"防区\"过去么？那么怎么阻击经过我秒杀系统的场景＂防区＂呢?或者说怎么设计和优化我防区的阻击能力呢？\n\n###  现场特点\n\n1. 大量用户在同一时间发起进攻, 造成瞬时的高流量.\n2. 访问量远远大于库存量．\n3. 业务流程就是下单并减库存.\n\n### 针对性的架构\n\n秒杀页面->服务器站点->服务层->数据库层\n+ 秒杀页面 \n  1. 静态化，在秒杀页面，就得将页面静态化, 除了必要的静态元素，其余的全部静态化，结合 CDN抵抗页面静态元素的访问．\n  2. 禁止用户重复提交, 提交过后按钮置为不可点击或者灰色.\n  3. 用户限流, 同一个IP用户一定时间内只允许提交一次订单.\n  4. 验证码填写识别.\n+ 服务器站点: \n  1. 限制用一个 UID 用户一段时间内的访问次数．\n  2. 采用消息队列缓存请求, 批量读取, 把多个请求的查询合并到一起进行, 减少数据库的访问次数．\n  3. redis 缓存查询的结果, 特别是库存量．\n+ 服务层\n  1. 分时分段分批次放票, \"骑兵\", \"步兵\"梯队放过处理．\n  2. 下订单模块(秒杀的核心部分), 队列控制异步化，做请求队列，判断读列是否已经满, 若未满，则将请求放到队列中;若已满, 则后面的请求返回秒杀失败. 总之, 单位时间只透过有限的\"部队\"(请求)去\"县城\"(数据库).\n  3. 下单, 异步付款．\n\n### 关键点\n1. 业务拆分, 独立并发访问.\n2. 高并发控制，请求量拦截．\n3. 读写分离(查询和下单拆分独立).\n4. 请求队列控制接受数，控制并发量.\n5. 订单和支付保持一致性．\n\n\n## 0x01 让暴风雨来的更猛烈些吧\n\n要点是层层阻击, 将流量压力拦在上游．减少到达写入数据库的增援部队数量．\n留给中国队的时间已经不多了，哦不，是留给 Bug 的时间已经不多了, 又错了，是留给增援到数据库的\"敌军\"(写操作)已经不多了......\n\n## 0x02 参考\n\n1. [秒杀系统架构优化之路.58沈剑](https://mp.weixin.qq.com/s?sn=fb28fd5e5f0895ddb167406d8a735548&__biz=MjM5ODYxMDA5OQ==&mid=2651959391&idx=1&scene=21&pass_ticket=5a1eixuRcaxaEfBB3VPh7z%2BRHowhFEJSqSWxYJTsomcQQ1yIU7LMGpQxjDey9Xgj)\n2. [如何设计一个秒杀系统](http://blog.csdn.net/suifeng3051/article/details/52607544)\n3. [Web系统大规模并发--电商秒杀与抢购.徐汉彬](http://www.csdn.net/article/2014-11-28/2822858)\n<!--more-->\n\n","tags":["计算机技术","Web"]},{"title":"设计模式-原型模式","url":"/2017-11-06-TheZenOfDesignPatternPrototype/","content":"\n设计模式第七式--原型模式。\n\n##  0x00 原型模式\n\n### 定义\n *Specify the kinds of objects to create using prototypical instance, and create new objects by copying this prototype.* \n (用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象。)\n\n<!--more-->\n\n通用类图\n![通用类图](../photos/prototype.png)\n\n#### 优点\n+ 性能优良, 原型模式在内存二进制流的拷贝, 要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时。 缺点也是减少了约束。\n\n#### 缺点\n+ 逃避构造函数的约束, 直接在内存中拷贝, 构造函数是不会执行的。优点是减少了约束，\n\n#### 使用场景\n类初始化需要消耗非常多的资源, 如: 数据, 硬件资源。\n1. 性能和安全要求的场景, 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限的情况，可以使用原型模式。\n2. 一个对象多个修改者的场景, 一个对象需要提供其他对象访问, 而且各个调用者可能都需要修改其值时, 可以考虑使用原型模式拷贝多个对象供调用者使用。\n3. 原型模式可和工厂方法模式一起使用, 通过 clone 的方法创建一个对象, 然后由工厂方法提供给调用者。\n\n\n#### 注意 \n* 构造函数不会被执行\n* 浅拷贝和深拷贝\n* 要使用 clone 方法， 类的成员变量上不要增加 final 关键字。\n\n#### php 实例 \n\n## 0x01 小结\n  原型模式先产生一个包含大量共有信息的类，然后进行拷贝副本(影分身), 修正细节信息, 建立一个完整的个性对象。\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-建造者模式","url":"/2017-10-26-BuilderPattern/","content":"\n##  0x00 建造者模式\n\n### 定义\n*Separate the construction of a complex object from its representation so that the same\nconstruction process can create different representations*. \n(将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示。)\n\n<!--more-->\n\n![](../photos/builder-pattern.png)\n\n#### 优点\n+ 封装性, 客户端不需要知道产品内部的细节.\n+ 建造者独立，容易扩展.\n+ 便于控制细节风险, 由于具体的建造者都是独立的，因此对建造过程中的逐步细化，不会影响到其他模块.\n\n#### 使用场景\n  * 相同的方法, 不用的执行顺序, 产生不同的事件结果时，可以采用建造者模式.\n  * 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同的，则可以使用该模式.\n  * 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效果，这个时候使用建造者模式非常合适.\n\n#### 注意\n建造者模式关注的是零件类型和装饰工艺(顺序), 这个是它与工厂模式最大不同的地方。\n\n#### PHP 实例\n\n```\n<?php\nabstract class AbstractQueryBuilder {\n    abstract function getQuery();\n}\n\nabstract class AbstractQueryDirector {\n    abstract function __construct(AbstractQueryBuilder $builder);\n    abstract function buildQuery();\n    abstract function getQuery();\n}\n\nclass Model {\n    private $sql = NULL;\n    private $sql_table = NULL;\n    private $sql_where = NULL;\n    private $sql_limit = NULL;\n\n    function __construct() {\n    }\n\n    function querySql() {\n        return $this->sql;\n    }\n\n    function table($table) {\n        $this->sql_table  = $table;\n    }\n\n    function where($where) {\n        $this->sql_where = $where;\n    }\n\n    function limit ($limit) {\n        $this->sql_limit = $limit;\n    }\n\n    function splicingQuery () {\n        $this->sql = 'SELECT * FROM ';\n        $this->sql .= $this->sql_table;\n        $this->sql .= ' WHERE ' . $this->sql_where;\n        $this->sql .= ' LIMIT ' . $this->sql_limit;\n    }\n}\n\nclass BaseQueryBuilder extends AbstractQueryBuilder {\n    private $query = NULL;\n    function __construct() {\n        $this->query = new Model();\n    }\n\n    function table($table) {\n        $this->query->table($table);\n    }\n\n    function where($where) {\n        $this->query->where($where);\n    }\n\n    function limit($limit) {\n        $this->query->limit($limit);\n    }\n\n    function splicingQuery() {\n        $this->query->splicingQuery();\n    }\n\n    function getQuery() {\n        return $this->query;\n    }\n}\n\nclass UserQueryDirector extends AbstractQueryDirector {\n    private $builder = NULL;\n    public function __construct(AbstractQueryBuilder $builder_sql) {\n        $this->builder = $builder_sql;\n    }\n\n    public function buildQuery() {\n        $this->builder->table('User');\n        $this->builder->where('id < 10');\n        $this->builder->limit('100');\n        $this->builder->splicingQuery();\n    }\n\n    public function getQuery() {\n        return $this->builder->getQuery();\n    }\n}\n\n$queryBuilder = new BaseQueryBuilder();\n$userDirector = new UserQueryDirector($queryBuilder);\n$userDirector->buildQuery();\n$userSql = $userDirector->getQuery();\n\nvar_dump($userSql->querySql());\n\n// string(42) \"SELECT * FROM User WHERE id < 10 LIMIT 100\"\n```\n## 0x01 小结\n各个设计模式之间有相似的地方. 比如封装性。\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-模板方法模式","url":"/2017-10-25-TheZenOfDesignPatternTemplateMethod/","content":"\n设计模式第四式--模板方法模式。\n\n##  0x00 工厂方法模式\n\n### 定义\n *Define the skeleton of an algorithm in an operation, deferring some step to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure* \n (定义一个操作中的算法的框架, 而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。)\n\n<!--more-->\n\n通用类图\n![通用类图](../photos/Template-method.png)\n\n#### 优点\n1. 封装不可变部分, 扩展可变部分。用不可变部分的算法封装到父类, 可变部分通过继承来扩展。\n2. 提取公共部分, 便于维护。\n3. 行为由父类控制，子类实现。基本的方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。\n\n#### 缺点\n模板方法模式属于像欧阳峰一样倒练《九阴真经》。正版的《九阴真经》或者一般的武学秘笈开篇应该是提纲挈领, 如独孤九剑，先讲抽象类负责声明最抽象、最一般的事物属性和方法--总决式，然后才娓娓道来破剑式，破刀式，破掌式, 破索式，破鞭式，破枪式，破箭式，破气式这些实现类的具体属性和方法。但是欧阳峰的模板方法模式, 照着黄蓉背给他的倒转的《九阴真经》, 头脚对调了，抽象类定义了部分抽象方法, 有子类实现，子类执行的结果影响了父类的结果, 所以子类对父类产生了影响，结果变得疯疯颠颠的了。“我是谁？欧阳峰是谁？”\n\n#### 使用场景\n1. 多个子类又公有的方法, 并且逻辑基本相同时。\n2. 重要、复杂的算法, 可以把核心算法设计为模板方法, 周边的相关细节功能则由各个子类实现。\n3. 重构时, 把相同的代码抽到父类中，通过钩子函数约束其行为。\n4. 具体如: 文件上传; 数据埋点上报等。\n\n\n#### 注意 \n* 为了防止恶意的操作, 一般模板方法都加上final关键字, 不允许被覆写。\n* 抽象模板中的基本方法尽量设计为protected类型, 符合迪米特法则, 不需要暴露的属性或方法尽量设置为protected类型。 实现类若非必要, 尽量不要扩大父类中的访问\n权限\n\n#### php 实例 \n\n```\n<?php\n// 独孤九剑\nabstract class Dugujiujian {\n    // protected 将独孤九剑剑法的招式秘密都保护起来，宁可烂在华山也不轻易传给华山弟子\n    protected abstract function zongjueStyle();\n    protected abstract function pojianStyle();\n    protected abstract function podaoStyle();\n    protected abstract function pozhangStyle();\n    protected abstract function poqiStyle();\n\n    // final 关键字限定，不能随便改剑谱要诀\n    final public function useDujiujian ()\n    {\n        $this->zongjueStyle();\n        $this->pojianStyle();\n        $this->podaoStyle();\n        $this->pozhangStyle();\n\n        // 如果功力深厚的，再教学破气式\n        if(!$this->isGonglishenhou()) {\n            echo( '功力不济, 江湖上历练几十年再领会破气式!' . PHP_EOL );\n        } else {\n            $this->poqiStyle();\n        }\n    }\n\n    // 钩子方法\n    protected function isGonglishenhou()\n    {\n        return true;\n    }\n}\n\nclass Fengqingyang extends Dugujiujian {\n    protected $deepNeili = true;\n    protected function zongjueStyle() {\n        echo('风清杨在教 总决式' . PHP_EOL);\n    }\n\n    protected function pojianStyle() {\n        echo('风清杨在教 破剑式' . PHP_EOL);\n    }\n\n    protected function podaoStyle() {\n        echo('风清杨在教 破刀式' . PHP_EOL);\n    }\n\n    protected function pozhangStyle() {\n        echo('风清杨在教 破掌式' . PHP_EOL);\n    }\n\n    protected function poqiStyle() {\n        echo('风清杨在教 破气式' . PHP_EOL);\n    }\n\n    protected function isGonglishenhou () {\n        return $this->deepNeili;\n    }\n\n    // 能不能教学破气式是由内力决定的\n    public function checkGongli($deepNeili) {\n        return $this->deepNeili = (bool) $deepNeili;\n    }\n}\n\nclass linghuchong extends Dugujiujian {\n    protected function zongjueStyle()\n    {\n        echo('令狐冲在学 总决式' . PHP_EOL);\n    }\n\n    protected function pojianStyle()\n    {\n        echo('令狐冲在学 破剑式' . PHP_EOL);\n    }\n\n    protected function podaoStyle()\n    {\n        echo('令狐冲在学 破刀式' . PHP_EOL);\n    }\n\n    protected function pozhangStyle()\n    {\n        echo('令狐冲在学 破掌式' . PHP_EOL);\n    }\n\n    protected function poqiStyle()\n    {\n        echo('令狐冲在学 破气式' . PHP_EOL);\n    }\n\n    protected function isGonglishenhou()\n    {\n        return false;\n    }\n}\n\nclass chuanshouDugujiujian {\n    public static function main ()\n    {\n        $fengqingyang = new Fengqingyang();\n        $deepNeili = 1;\n        if(!$deepNeili) {\n            $fengqingyang->checkGongli($deepNeili);\n        }\n        $fengqingyang->useDujiujian();\n\n        $deepNeili = 0;\n        $linghuchong = new Linghuchong();\n        $linghuchong->useDujiujian();\n    }\n}\n\nchuanshouDugujiujian::main();\n\n    // 风清杨在教 总决式\n    // 风清杨在教 破剑式\n    // 风清杨在教 破刀式\n    // 风清杨在教 破掌式\n    // 风清杨在教 破气式\n    // 令狐冲在学 总决式\n    // 令狐冲在学 破剑式\n    // 令狐冲在学 破刀式\n    // 令狐冲在学 破掌式\n    // 功力不济, 江湖上历练几十年再领会破气式!\n```\n\n## 0x01 小结\n使用风清杨教令狐冲独孤九剑的一段经历模拟了一下模板方法模式, 虽然有些生硬，但也是自己对模板方法模式的一个理解吧。反正都要自己去实现一遍, 慢慢消化吸收。哪怕就着芥末吃，也先咽下去。\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-抽象工厂模式","url":"/2017-10-24-TheZenOfDesignPatternAbstractFactory/","content":"\n\n##  0x00 抽象工厂模式\n\n### 定义\n *Provide an interface or creating families of related or dependent objects without specifying their concrete classes* \n (为创建一组相关或相互依赖的对象提供一个接口, 而且无须指定它们的具体类。)\n\n 抽象工厂模式的通用类图:\n![](../photos/abstract-factory.png)\n![](../photos/abstract-factory-source.png)\n\n<!--more-->\n#### 区别于工厂方法模式\n\n1. 子工厂必须全部继承或实现自同一个抽象类或接口. \n2. 每个工厂必须包含多个工厂方法. \n3. 每个工厂的方法必须一致\n\n#### 优点\n+ 封装性, 每个产品的实现类不是高层模块需要关心的, 它只关心接口和抽象，它不关心对象是如何创建出来。只要知道工厂类是谁，就能创建出来一个需要的对象。\n+ 产品族内约束是非公开状态, 是在工厂内实现的。\n\n#### 缺点\n产品族扩展非常困难。需要同时修改抽象类和实现类.\n\n#### 使用场景\n一个对象族都有相同的约束，就可以使用抽象工厂模式. 比如 php 在 linux 和 windows 下面的运行效果看上去一样，也就是相当于有一样的约束条件: 操作系统类型。那么就可以使用抽象工厂模式, 产生不同操作系统下的 php 安装途径。\n\n#### PHP 实现\n\n```php\n<?php\n\nabstract class population {}\nabstract class income {}\n\nclass ShenzhenPopulation {}\nclass ShenzhenIncome {}\nclass BeijingPopulation {}\nclass BeijingIncome {}\n\ninterface NationalStatisticsAbstractFactory {\n    public function statisticsPopulation();\n    public function statisticsIncome();\n}\n\nclass ShenzhenFactory implements NationalStatisticsAbstractFactory {\n    public function statisticsPopulation() {\n        return new ShenzhenPopulation();\n    }\n\n    public function statisticsIncome() {\n        return new ShenzhenIncome();\n    }\n}\n\nclass BeijingFactory implements NationalStatisticsAbstractFactory {\n    public function statisticsPopulation (){\n        return new BeijingPopulation();\n    }\n\n    public function statisticsIncome () {\n        return new BeijingIncome();\n    }\n}\n```\n深圳工厂和北京的工厂类(ShenzhenFactory, BeijingFactory)都继承自 国家统计抽象接口(NationalStatisticsAbstractFactory), ShenzhenFactory 和 BeijingFactory 都分别包含统计收入(statisticsIncome)和统计人口(statisticsPopulation)的方法.\n\n## 0x01 小结\n设计模式要细细品尝, 值得花时间研究.\n\n<!--more-->\n","tags":["设计模式"]},{"title":"设计模式-工厂方法模式","url":"/2017-10-23-TheZenOfDesignPatternFactory/","content":"\n设计模式第二式--工厂方法模式, 改模式使用的频率非常高。所以排在前面一点学。\n\n##  0x00 工厂方法模式\n\n### 定义\n  *Define an interface for crating an object, but let subclasses decide which class to instantiate. Factor Method lets a class defer instantiation to subclasses.* \t\t + *Separate the construction of a complex object from its representation so the same construction can create different representation* \n - (定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。)\n\n<!--more-->\n\n#### 解读\n具体的产品类可以有很多个，都继承于抽象产品类。\n抽象工厂类负责定义产品对象的产生。\n具体如何创建一个产品的对象，是由具体的工厂类实现的。\n\n#### 优点\n1. 良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名即可。无须知道创建对象的艰辛过程，降低模块间的耦合。\n2. 工厂方法模式的易扩展性。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以实现“拥抱变化”。\n3. 屏蔽产品类。因为产品类的实例化由工厂类负责，调用者不需关心产品类的实现如何变化，只关心产品的接口。接口不变，系统中的上层模块就不用发生变化。比如: 使用工厂方法模式连接数据库, MySQL 切换到 Oracle 只需要切换驱动名称即可。\n4. 解藕框架。\n\n#### 使用场景\n1. 工厂方法模式是 new 一个对象的替代品，如果增加一个工厂类并没有增加代码的复杂度，在需要生成对象的地方都可以使用。\n2. 灵活的、可扩展的框架可以采用工厂方法模式。万物皆对象。比如: http, udp协议的连接方法中就可以使用．\n3. 工厂方法模式可以用在异构项目中．\n4. 可以使用在测试驱动开发的框架下．\n\n#### 扩展\n1. 缩小为简单工厂模式．去掉抽象类, 并使用 static　关键字．\n2. 升级为多个工厂类．\n3. 替代单例模式.　单例模式核心要求是内存中只有一个对象，通过工厂方法模式就可以只在内存中生产一个对象．\n4. 延迟初始化．一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用．\n\n## 0x01 小结\n工厂方法模式暂时理解为，你给我一个物品名，丢给车间, 完成生产．\n<!--more-->\n","tags":["设计模式"]},{"title":"最没出息的9大根源","url":"/2017-09-26-No_Special_People/","content":"\n## 研究表明\n\n哈佛的一项研究表明: 一个人没有出息主要有以下九大根源。\n\n### 犹豫不决\n\n\"畏惧错误就是毁灭进步\"。雷厉风行很容易出错，但是原地踏步什么也不做更糟糕。\n<!--more-->\n\n### 拖延\n\n懒惰和拖延，可以将一个有前途的计划活活闷死。迟迟不开始，或者遇到问题就推托，很容易将横在面前的困难放大，望而却步。借口根本不能解决问题。消极的心态，一旦蔓延开来，犹如蒲公英的种子一样，撒得到处都是。而如果踏进拖延的沼泽, 只会越陷越深, 无法自拔。随着时间的流逝，人的内心逐渐产生沉重的愧疚和自我否定。\n\n### 三分钟热度\n\n这个我感触太深了: 一开始制定了雄心勃勃的计划， 最后以心灰意冷草草收场。兴趣太广泛，多数事情都是浅尝辄止。以至于在紧要关头的事情上，时有半途而废的情况出现。而作出那些时刻的决策，自己都没有认真考虑清楚后果，有的自己都没有自知。事后回想起来，才发现错过了很多。坚持，才能熬过枯燥，迎来成功, 体会到收获的喜悦。\n\n### 害怕拒绝\n\n怕拒绝, 厚重而脆弱的自尊，混在人际中感觉无名的痛。还是应该放下自尊去做事情，专注到成果的方向上去。少关注他人对自己做事的态度。\n\n### 自我设限\n\n这个杀死自己能力的心里暗示行为，估计很多人都会有。\n\n### 逃避现实\n\n1. 怎么感觉又是在说我。年少时，经常做白日梦，梦想着会飞，三分投篮可以百分百中......躲进自己的没有风雨的小楼里。\n2. 喜欢随心所欲，无拘无束的生活。大学的时候，整天想的就是玩了。每到寒暑假，就跑出去周游，那时候，足迹遍布了全国的天南地北。和朋友聊天的时候，还以为别人聊到这个问题时，是在夸自己。殊不知，这些都是逃避现实的体现。知心朋友不会指出来的: 你这个游手好闲的家伙!\n3. 沉迷游戏和魔幻小说。其实，我在想，喜欢看电影和电视剧的，何尝又不是逃避现实！而这些，之前每一样我都占了。\n\n有逃避现实的这些行为的人，会以为是想过的是惬意快乐的生活， 事实上导致的却是与日常生活格格不入的烦躁和不安。\n\n### 总找接口\n\n找接口，恐怕是这个星球上除了生存之后最容易的事情了? 有习惯找接口的人，基本都是一些没有强烈的事业心，没有执着的追求的人。一出错，往往第一时间先把自己摘得干干净净，以为事出不在我的态度。不管是出于自我保护还是撇清责任，这些人在社会上总是有的。很难合作。出了bug, 不在第一时间解决问题，却想着气势凶凶追究后果，指责别人的行为，这种自我安慰的行为实在可恶。谁还没出错的时候？遇到困难，遇到问题，要去承担，要去解决。遇到风险，需要去挑战。不能退缩！\n\n### 恐惧\n\n 谨小慎微的活着，怕这怕那的。可能这个和年龄、阅历都有些关系。以前都是天不怕，地不怕的。大学毕业之后，还是大学开始之后，就各种害怕，接踵而至了。仿佛是依附在身上的细菌一般。害怕批评，害怕失败，害怕结果，在意别人的评价和态度，害怕自己的缺点，害怕变成无能。想想看，这是多么脆弱的心智啊？\n \n### 拒绝学习\n\n在互联网领域，以现在的发展速度, 半年不学习，便恍如脱离了这个世界半个世纪以上。\n\n## 小结\n\n拼尽全力去学习，去体验，去生活, 去追求吧。每一天都是那么特殊，每一天都是那么弥足珍贵。多少人没有我们现在的条件，却还能作出那么多对家人，对社会，对大众有意义的事情? 何况。。。。。。\n\n<!--more-->\n","tags":["点滴"]},{"title":"《天道》","url":"/2017-09-07-distant-savior/","content":"# 《遥远的救世主》--电视剧《天道》\n## 文化属性\n+ 透视社会依次有三个层次 *技术，制度和文化。小到一个人，大到一个国家一个民族，任何一种命运归根到底都是那种文化属性的产物。强势文化造就强者，弱势文化造就弱者，这就是规律，也可以理解为天道，不以人的意志为转移* 。\n+ 强势文化就是遵循事物规律的文化，弱势文化就是依赖强者的道德期望破格获取的文化，就是期望救世主的文化。强势文化在武学上被称为“秘籍”, 而弱势文化由于易学、易懂、易用，成了流行品种。\n+ 比如说文化产业，文学、影视是扒拉灵魂的艺术，如果文学、影视的创作能破解更高思维空间的文化密码，那么它的功效就是启迪人的觉悟、震撼人的灵魂，这就是众生所需，就是功德、市场、名利，精神拯救的暴利与毒品麻醉的暴利完全等值，而且不必像贩毒那样耍花招，没有心理成本和法律风险。 \n+ 没有 *主* ，主义、主意从哪里来？主无处不在，简单地说， *支配人的价值取舍行为的那个东西就是主，就是文化属性* 。\n+ *文明* 对于不能以人字来界定的人无能为力。\n+ 死马当做活马医，再糟，死马还能再死一回吗？\n+ 股票的暴利并不产生与生产经营，而是产生与股票市场本身的 *投机性* 。它的运作动力是：把你口袋里的钱装到我的口袋里去。它的规则是：把大多数羊的肉填到极少数狼的嘴里。\n+ 法律机器的运作不以口供为条件。法律对程序和内容要求极限的严谨。\n+ 强盗的逻辑，直接获取，冒险，刺激。\n+ 强盗的本质是破格获取， *破格获取* 和 *直接获取* 是两个不同的概念。你们没有自信与强者在同一个规则下公平竞争，这只能说明你是弱者，因为弱者文化所追求的最高价值就是破格获取。所以，强盗的逻辑从本质上讲是最懦弱的生存哲学。\n+ 拯救灵魂是《圣经》的买卖。\n+ 《圣经》的理由是：因信着得救了，上天堂；因不信有罪了，下地狱。用这种哄孩子的、吓汉子的方法让人去信，虽有利于基督教的实践，却也迎合了人的怕死的一面、贪婪的一面。这样的因果关系已经不给人以自觉、自省的机会，人连追求高尚的机会都没有，又何以高尚呢？\n+ 神是什么？神是根据人的需要造出来的。（容我仿一下：鬼是什么？鬼是根据人的恐惧造出来的。）\n+ 《圣经》神学是关于人类精神的学说，是关于人的灵魂净化、升华，人的行为高尚、正典的学说。一味地攻击或捍卫神的真实性与否，都是愚昧的表现。前者没有理解基督教的历史价值和社会价值，后者没有理解基督教的真正境界。\n+ 神是什么？  *神即道，道法自然，如来*  。\n+ *你不知道你，所以你是你，如果你知道了你，你就不是你了。*\n+ 这世上原本就没什么神话，所谓的 *神话* 不过是常人的思维所不易理解的平常事。\n+ 无论做什么，市场都不是一块无限大的蛋糕。神话的实质就是强力作用的杀富济贫。这就可能产生两个问题，一是杀富是不是破坏性开采市场资源？二是让井底的人扒着井沿看了一眼再掉下去是不是让他患上精神绝症。\n+ 佛家常说“ *证到* ”这个词，却从来不告诉你“证到”后面是什么，因为欲说欲解都不能，因为条件的条件的条件，因为因果的因果的因果，所以就有了如人饮水冷暖自知。\n+ 这就是圆融世故，不显山不露水，各得其所。可品性这东西，今天缺个角、明天裂道缝，也就离塌陷不远了。\n+ 社会对公司的好感也是商业好处的一部分。这不是道德境界问题，是市场生存的法则问题。这种好感不仅仅是我们强行摊派价值观，也不仅仅是腐蚀我们自身的竞争力，更说明我们不是靠产品征服市场而是靠作秀混迹市场，这种违背商业属性的人文评价最终将葬送这个公司。\n+ *生存法则* 很简单，就是 *忍人所不能人，能人所不能* 。忍是一条线，能是一条线，两者的间距就是生存机会。如果我们忍人所不忍，能人所不能，咱们就比别人多了一些生存机会。市场的生存竞争非常残酷，胜负往往就在毫厘之间, *两败俱伤你比他多一口气，你就是赢家* 。（暗合围棋屠龙对杀）\n+ 扬长避短，拾遗补缺，学会夹缝里面求生存。\n+ 公司必须以不断开拓市场和完善服务来抵御市场风险。\n+ 翻开历史看看，你从哪一行哪一页能找到救世主救世的记录。没有，从来就没有，从来都是救人的被救了，被救的救了人。如果一定要讲救世主的话，那么 *符合和代表客观规律的文化* 就是救世主。\n+ 扶贫的本质在一个扶字，如果你压根就没有打算自己站起来，老天爷来了都没用。\n+ *法无定法，存在决定意识* 。\n+ 《悟》\n  - 悟道休言天命，\n  - 修行勿取真经。\n  - 一悲一喜一枯荣，\n  - 哪个前生注定？\n  - 袈裟本无清净，\n  - 红尘不染性空。\n  - 幽幽古刹千年钟，\n  - 都是痴人说梦。\n\n+ 所谓真经，就是能够打到寂空涅槃的究竟法门，可悟不可修。修为成佛，在求。悟为明性，在知。修行以行制性，悟道以性施行，觉者由心生律，修者以律制心。不落恶果者有信无证，住因住果，住念住心，如是生灭。不昧因果者无住而住，无欲无不欲，无戒无不戒, 如是涅槃。\n+ 佛乃觉性，非人，人人都有觉性不等于觉性就是人。人相可坏，觉性无生无灭，即觉即显,即障即尘弊，无障不显，了障涅槃。觉行圆满之佛乃佛教人像之佛，圆满即止，既非无量。若佛有量，即非阿弥陀佛。佛法无量即觉行无量，无圆无不圆，无满无不满，亦无是名究竟圆满。佛教以次第而分，从精深处说是得道天成的道法，道法如来不可思议，即非文化。从浅义处说是导人向善的教义，善恶本有人相、我相、众生相，即是文化。从众生处说是以贪治贪、以幻制幻的善巧，虽不灭败坏下流，却无碍抚慰灵魂的慈悲。\n+ 坐，请坐，请上座。茶，上茶，上好茶。\n+ 投石击水，不起浪花也泛涟漪，妙在以扶贫而命题。当有识之士骂你比强盗还坏的时候，责骂者，责即为诊，诊而不医，无异于断为绝症，非仁人志士所为，也背不起这更大的骂名。故而，责必论道。\n+ 传统观念的死结就在一个 *靠* 字上，在家靠父母，出门靠朋友，靠上帝、靠菩萨、靠皇恩。。。。。。总之靠什么都行，就是别靠自己。这是一个沉积了几千年的文化属性的问题，非几次新文化运动就能开悟。\n+ *大爱不爱*\n+ 弱势得救之道，也有也没有。没有竞争的社会就没有活力，而竞争必然会产生贫富、等级，此乃天道，乃社会进步的必然代价。无弱，强焉在？一个 *强*　字，　弱已经在其中了。故而，佛度心苦，修的是一个平常心。\n+ *释、道、儒* 是中国传统文化的三大体系。传统文化毕竟是以皇恩浩荡为先决条件的文化，讲的都是 *皆空、无为、中庸* 的理，以抑制个性而求生求解。\n+ 没有地狱，天堂焉在？总得有人在地狱呆着，咱们就算上一个，不然天堂就没有着落了。\n+ 天下之道论到极致，百姓的柴米油盐。人生冷暖论到极致，男人女人的一个 *情* 字。\n+ 佛说 *看山是山，看水是水* ，我只是依佛法如实观照，看摩登女郎是摩登女郎，看红颜知己是红颜知己。\n+ 栏内是净，栏外是土，靠着栏杆就能抽烟。\n+ 有人、有枪、有地盘，还愁没有番号吗？\n+ *骆驼穿针* 的天堂(？没理解)\n+ 你信神吗？ *了妄唯真* 即是神（了妄唯真?）了妄唯真,那神和人是什么关系？　不一不异\n+ 旅游就是意图，开阔眼界、增长见识就是意图。\n+ 想到了就做，该拿的拿该放的放，自性作为不昧因果。\n+ 从现象参到制度、参到文化，因为任何一种命运，归根到底都是那种文化的产物。\n+ 衡量一种文化属性不是看它沉淀的时间长短，而是看它与客观规律的距离远近。五千年的文化是光辉、是灿烂，这个没有问题，但是，传统和习俗得过过客观规律的筛子。\n+ 有文化和有什么文化不是一个概念。\n+ 不该作为的不作为就是作为，能活个明白就不错了。\n+ 好声本身的魅力已经足够了，不在需要无谓的修饰和点缀。\n+ 如果我的能力只能让我穷困潦倒，那穷困潦倒就是我的价值。\n+ 每个人的立场、观念、心态和思维模式不一样，获取的信息量和解读信息的方式也不一样。\n+ *好听* 就是艺术，只是每个人的好听标准不一样。\n+ 能做到 *实事求是* 的就是神话。能说老实话，能办老实事的人就是神。\n+ 神就是道，道就是规律, 规律如来，容不得你思议，按规律办事的人就是什么。\n+ 人从根本上只面对两个问题： *一是生存，得活下来；二是得回答生命价值的问题，让心有个安住* 。\n+ 5年之后我不嫌你老，你就可以不老了吗？５年以后我变成了一个色狼，值得你回头看一眼吗?\n+ 不以求职应聘为生。要学位意义不大，应该什么有用学什么。\n+ 不管是文化艺术还是生存艺术，有道无术，术尚可求也。有术无道，止于术。\n+ *立志要高，挖掘要深。*\n+ 外国不是我们家的厨房，不是我想进就进。有钱的男人也不是菜市场里的鸡蛋，不是我想抓一个就抓一个。\n+ 马太效应： *你有，给你更多；你没有，把你原来的都拿走*\n+ 当人一旦从危险里跳出来，他就不再去关注这个事物的危险了，他的目光就会全部落在这个事物的利益人上，这就是人。\n","tags":["点滴","读书"]},{"title":"《失控》","url":"/2017-09-01-Out-of-Control/","content":"#  《失控》-- 全人类的最终命运和结局？\n## 自我能动\n  + 有机体既是它自己的因也是它自己的果，既是它自己固有的秩序和组织的因，也是其固有秩序和组织的果。\n  + 每一个 *自我* 都是一个同义反复：自明、自指、以自己为中心并且自己创造自己。\n  + 一个 *系统* ，就是任何一种能够自说自话的东西。\n  + 自动控制三个阶段\n    - 由蒸汽机所引发的能量控制的第一阶段\n    - 对物质的精确控制是第二阶段\n    - 对信息本身的控制是第三阶段\n  + 21 世纪的核心事件，是对 *信息的颠覆* 。\n  + 自动化的历史，就是一条 *从人类控制到自动控制* 的单向通道。其结果就是从人类的自我到第二类自我的不可逆转的转移。而第二类自我是在我们控制之外的，是失控的。\n  + 具有自我适应能力、像自己的目标进化、不受人类监管自行成长的机器，将会是下一个巨大的技术进步。要想获得有智能的控制，唯一的办法就是给机器自由。\n  + 有些事必须先做，而且要按 *正确的次序* 去做。\n  + *复杂的机器必定是逐步地，而且往往是间接地完善的。别指望通过一次华丽的组装就能完成整个工作正常的机械系统。你必须首先制作一个可运行的系统，再以此为平台研制你真正想完成的系统* (精辟呀!微信,Facebook也是一步步来的)。\n\n## 密封的瓶装生命\n\n  + 一天就可以摧毁的东西，要想建成它，可能会需要几年甚至几个世纪的时间。\n  + 复杂性的开端根植于混沌之中。不过，如果复杂系统能够在一段时间的互相迁就之后获得共同的 *平衡* ，那么之后就再没有什么能够让它脱离轨道了。(是不是和习惯一样？一旦养成了自己固定的生活习惯，思维习惯，就会潜意识地贯彻下去。)\n  + “封闭”意味着与流动隔绝。一个真正的封闭系统，是不会参与外部元素流动的; 换句话，它所有的循环都是自治的。\n  + “系统”意味着相互 *连通* 。系统中的事物是相互纠结的，直接或者间接地连接到一个共同的命运。\n  + *“存活”意味着惊喜* 。\n  + 静态才是生态球的常态。\n  + 生态球按比例放大后仍很完好。生态球越大，达到稳定所需时间就越长，破坏它也就越困难。只要处于正常状态，一个活系统的集体代谢过程就会扎下根，然后一直持续下去。\n\n## 生态技术玻璃球\n\n  + 生命经营的事业就是改造环境使其有益于生命。如果你能把生命聚拢成为一个群落，给它们充分的自由制造自己茁壮成长所需的条件，这个生物集合体就能一直生存下去，也没有必要知道它是怎样运转的。\n  + 对于任何一个复杂、危险的项目来说，最理想的团队人数是８个人。超过８个人，会造成决策缓慢和耽搁；而少于８个人，突发事件或者疏忽大意就会变成严重的阻碍。\n  + 细节是至关重要的东西。\n  + 生命的任何领域都是由数不清的独立的回路编织而成的。\n\n## 合成生态系统\n\n+ 一旦你改变了生态系统，　并找到适合播种的的种子，以及必不可少的气候窗口，改变就开始了，而且这是不可逆转的。这个合成的生态系统持续运转下去并不需要人的存在，它不受干扰仍会保持下去。\n+ 创造生物圈：\n  - 微生物做绝大部分的工作\n  - 土壤是有机体, 它是活的。它会呼吸。\n  - 创造【冗余】的食物网络\n  - 逐步地增加多样性\n  - 如果不能提供一种物理功能，就需要模拟一个类似的功能\n  - 大气会传达整个系统的状态\n  - 聆听系统，看看它要去哪里\n+ 所有的封闭系统都是会被打开的，至少会出现泄露。(也就是: 不存在绝对封闭系统)\n## 冒出的生态圈\n+ 人体本身就是一个巨大的复杂系统。我们从自然中获得的施与是令人难以置信的。\n+ 扰动是生态的必要催化剂。\n+ 我们究竟可以切断多少的联系，还能保持一个物种的生存。\n+ 命运始终具有讽刺意味。\n+ 顺其自然就好。\n+ 大气是极其重要的环境因素，大气产生生命，生命也可以产生大气。\n+ 不要着急，不要在系统自组织的时候就急着催它孕育。你能给它的最重要的东西就是 *时间* 。\n+ 所有复杂的共同进化系统都需要“ *冒出* ”。\n+ 可以通过逐渐提高复杂性来重组大型系统；一旦一个系统达到了稳定水平，它就不会轻易地趋向于倒退，仿佛这个系统被新的复杂性带来的凝聚力所“吸引”。人类组织，比如团队和公司，也显示出 \" *冒出* \"的特征。\n+ *生命就是技术* 。机器技术只不过是生命技术的临时替代品而已。随着我们对机器的改进，他们会变得更有机，更生命化，更近似生命， *因为生命是生物的最高技术* 。总有一天，机器和生物间的差别会很难区分。\n\n## 看不见的智能\n\n+ 最深刻的技术是那些看不见的技术，它们讲自己编织进日常生活的细枝末节之中，直到成为生活的一部分。书写的技术走下精英阶层，不断放低身段，从我们的注意力中淡出。\n+ 电脑的胜利不但不会使世界非人化，反而会使环境更臣服于人类的愿望。我们创造的不是机器，而是讲我们所学所能融会贯通于其中的机械化环境。我们在将自己的生命延伸到周边环境中去。\n+ 缺少了隐私技术的网络文化是无法兴旺的。\n+ 哪里有生态系统，哪里就有精通本地事务的生命。\n+ 人类渴求隐私，但事实上，我们的社会性胜过独立性。如果机器也像我们这样互相了解（甚至是一些很私密的事情），那么机器生态就是不可征服的。\n+ 自然界没有垃圾问题，因为物尽其用。\n+ 想大自然一样从事。\n+ 机器是整体系统, 强调系统效率最大化。将自然环境的模式作为解决环境问题的模板。\n+ 尽可以将所有能想到的废物都看作是潜在的原材料。任何在当下没有用的材料，都可以通过设计从源头将它消除。\n+ 生态技术即使带不来令人震惊的利润，也会带来一定的成本收益。\n+ 工业将无可避免地采用生物方式\n  - 它能用更少的材料造出更好的东西。\n  - 自然是掌控复杂性的大师，在处理杂乱、反直观的网络方面给我们以无价的引导。未来的人造复杂系统为了能够运转，必然会有意识地注入有机原则。\n  - 大自然是不为所动的，所以必须去适应她。\n  - 自然界本身－－基因和各种生命形式－－与工业系统一样能够被工程化（或模式化）。\n  - 生物学是一个必然－－近于数学的必然，所有复杂性归向的必然。它是一个欧米茄（Omega）点。在天生和人缓慢的混合过程中，有机是一种显性性状，而机械是隐性性状。最终，获胜的总是生物逻辑。\n\n## 信息工厂\n+ 一个纯粹网络化的公司，应该具备这些特点\n  - 分布式\n  - 去中心化\n  - 协作\n  - 可适应性\n+ 在大多数情况下，真正的财富都是通过把某种流程置于集中控制之下而获得的。越大，效率越高。\n+ 如果把一个任务拆分成若干块交给不同的公司来完成，若想保持质量的话，所需的交易成本要高于在一个公司内完成这项任务的成本。\n\n## 与错误打交道\n+ 软件的编制遵循三个中心化的关键步骤。\n  - 首先设计一个全景图\n  - 然后用代码实现细节\n  - 最后，在接近项目尾声的时候，将其作为交互的整体来进行测试。\n+ 绝对不可能避免错误，但是可以避免错误成为缺陷。零缺陷设计的人物就是尽早发现错误，尽早改正错误。真正的改进在于尽早发现产生错误的原因，并尽早清除产生错误的原因。犯错的是人，处理错误的是系统。\n+ 当你发现一个错误的时候，也就意味着还有另外一堆你没看见的错误在什么地方等着你。\n+ 新生物学的解决之道是用一个个可以正常的单元来搭建程序性。\n+ 一个好的程序员可以对任何一个已知的、规律的软件进行重写，巧妙地减少代码。但是，在创造性编程过程中，没有任何已经被完全理解的东西。\n\n## 联通所有的一切\n\n+ 新兴网络经济具备的特征\n  - 分布式核心\n  - 适应性技术\n  - 灵活制造\n  - 批量化的定制\n  - 工业生态学\n  - 全球会计\n  - 共同进化的消费者\n  - 以知识为基础\n  - 免费的带宽\n  - 收益递增\n  - 数字货币\n  - 隐性经济\n+ 这个时代里，最核心的行为就是把所有的东西都联结在一起。\n\n## 密码无政府状态 \n\n+ 要阻止信息的越界流动是一件毫无希望的事情。\n+ 在信息时代，情报成为企业最主要的财富。\n\n## 数字货币\n\n- 消费历史可以被用来构成一份精准且极具市场推广价值的档案。\n- 真正的数字现金是真钱，具有现金的私密性和电子的灵活性。\n- 安全性和私密性是矛盾的两面。\n- 信息流动到哪里，货币肯定也会跟随其后。货币是另一类信息，一种小型的控制方式。\n- 真正的数字现金，或者更准确地说，真正的数字现金所需要的经济机制，将会重新构造我们的经济、通讯以及知识。\n","tags":["读书"]},{"title":"Emacs 漫步-- org-mode 二三事之 link","url":"/2017-08-15-emacs-org/","content":"\n## org-link\n\nemacs 内使用 Alt + X 调起 helm 界面。 helm 界面可以在输入模式下直接调起。不像vim。 输入 org-link 可以看到各种有关 org-mode 下 link 相关的操作。helm 非常友好，只要输入相关关键字的命令名称，就给列出来所有包含这个关键字的命令了。而且输入这些关键字查询的时候, 可以不分次序!\n\norg-mode 下的 link 是这样款式的 [[http://www.gnu.org/software/emacs/][GNU Emacs]], [http://wowubuntu.com/markdown/](markdown的链接方式), 大同小异。正常情况下 org-link 带有三个中括号，内部第一个中括号是链接地址，可以是文件路径，图片地址，http 超链接，第二个中括号是这个链接的描述，描述可以为空 如 [[http://www.gitvim.com]]。\n\n列举几个常用的 link 操作: \n\n1. org-insert-link\n顾名思义， 添加一个带有链接和描述的超链接文案, 先输入 link, 然后是 description。\n\n2. org-toggle-link-display\n可以切换 link 和 description 之间的显示, 方便修改描述和链接地址。 \n\n3. org-store-link\n用于...这个诡异\n\n4. org-previous-link & org-next-link\n双胞胎, 前后跳转到链接的命令。\n\n \n\n## 小结\nEmacs 这种程序国之重器, 思量之，适可而止。\n","tags":["Emacs","编辑器"]},{"title":"Emacs 漫步-- 快捷键入口","url":"/2017-07-21-emacs/","content":"\n##  Space 系列\n\n空格键 space 开始的快捷键非常多, 查看方式，敲下 Space 键，瞬间出来第一层以 space 为绑定的快捷键。 之后，还有以关键字打头阵的第二层快捷键。\n\n### +f 系列\n 就是和文件相关的。需要直接在 emacs 内部使用 sudo 命令编辑的文件，可以使用 *space + f + E* 启动。\n### +p 系列是和项目有关联的，\n如 +p 进去，发现 *space+p+t* 就是查看根目录的 nerdtree 文件目录管理。\n### +b buffer 系列\n直接 space+b+b 最近编辑过的文件的 buffer 一览无余。\n### +g git 系列\n各种操作 git 命令的快捷键。下雨天，magit 和 emacs 更配哟。\n### +h 帮助 \nspace+h 是各种 emacs 快捷键的前置快捷键\n### +! shell 命令快捷键\n直接执行 shell 命令。So cool~\n### +n 数字窗口切换\n就是以窗口序号 1-n 之间的切换。\n\n![space快捷键大观园](https://raw.githubusercontent.com/chenyangguang/StudyNotes/master/photos/space.png)\n<!--more-->\n\n## Ctrl+c 系列\n\nctrl + c 系列， 有大量 org-mode 和 markdown 的玩法。 \n比如 *ctrl+c+t* 进行 todo-list 的进度管理\n\n![ctrl+c 系列快捷键](https://github.com/chenyangguang/StudyNotes/blob/master/photos/ctrl-c.png?raw=true)\n\n## Ctrl+x 系列 \n\n![ctrl+x系列](https://github.com/chenyangguang/StudyNotes/blob/master/photos/ctrl-x.png?raw=true)\n\n## , 逗号系列\n\n![逗号系列](https://github.com/chenyangguang/StudyNotes/blob/master/photos/douhao.png?raw=true)\n比如快速的插入一个 markdown 格式图片使用 *,+i+i*\n<!--more-->\n\n## 小结\n一句话: 玩溜了，Emacs 之内，舒服。\n","tags":["Emacs","编辑器"]},{"title":"Hexo blog begin","url":"/2017-05-01-hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["点滴"]},{"title":"Clean Code","url":"/2017-04-25-clean-code/","content":"## 为啥看《Clean Code》 \n将需求明确到机器可以执行的细节程度，就是编程要做的事，这种归约正是代码。\n重新审视自己写过的一些业务代码，发现依然是个熊样儿。学习一下《代码整洁之道》, 让自己的代码整洁一些。虽然启示本身不值钱，但是学习启示与案例研究中清理代码的具体决策之间的关系，对现在的我是有很大帮助的。\n\n## 小处见大\n软件无论写得多庞大，神在细节之中。\nHe who is faithful in little is faithful in much.\nMighty oaks from little acorns grow.\n“小处诚实非小事”。\n\"物皆有其位，而后物尽归其位\"。\n\n## \n","tags":["灵犀指","代码","编程"]},{"title":"瑞士军刀片 awk","url":"/2017-04-25-awk/","content":"\n\n###  awk 起源之美女选男朋友\n\n说起瑞士军刀，可能很多人都听腻了。 有说 Emacs 是瑞士军刀的， 有说 Vim 也是瑞士军刀， 有说 Python 是瑞士军刀的。但是让我们暂时抛开对瑞士军刀的兴趣, 来拨弄一下一页小小的瑞士军刀片-- awk。这个小家伙是一门小巧玲珑的特殊的编程语言。\n<!--more-->\n \n不可我， 总结了一个最好的认识新事物的方法: 迎面冲上去。\n看下面这组相亲数据 gfs.data : \n \n```\nLi 65 177 10000\nWang 77 180 8000\nNiu 60 199  20000\nChen 64.5 168 5000\nOuyang 80 200 12000\nLiu 72.5 182 9999\n```\n\n这片小数据里面包含几个字段， 人名，体重，身高, 月收入的数据。 比如美女需要从这里挑选男朋友标准，怎么选出这里面身高 177 以上的高富帅呢？ \n\n```\n➜  tmp awk ' $3 > 177 { print $1,$3}' gfs.data \nWang 180\nNiu 199\nOuyang 200\nLiu 182\n```\n\n tmp 是临时目录，这个是 zsh 里面的一个短路径，略过。 awk 程序的结构是 *pattern { action }* 的结构。\n它会默认将字段看作非空白字符组成的序列。（所以你看那些中间的安安静静的空格，被当成是空气了。）剩下的，第一个字段姓名，就是 *$1*, 第二个体重是 *$2*, 177， 180, 199, 168, 200,182这些身高值就是 *$3*了, 依次类推下去。 整个一行是 $0。每个人的颜值，身家是可能不一样的, 也就是说 *$n* 的值长度是不一定一致的。\n\n 单引号包起来的 *$3 > 177* 是对每行扫描匹配的条件。当扫到 Wang 时， 很明显这家伙 180 超出预期值，需要多瞄几眼，看是否是 \"八字\" 合的来的真名天子，被挑出来了。按照这个模式一直搜到最后行， Liu 这个哥儿们也中彩了。\n如果这位美女眼光比较高，她找男朋友的条件比较多，比如，收入要高，体重要匀称，智商要高等， 这样的话，最好是将她的条件给写到一个文件里面去， 名值曰: conditions.data。一次给她选中得意郎君。\n\n```\nawk -f conditions.data gfs.data\n```\n\n*-f* 表示从文件中提取程序，这个标准可以给多个姑娘参考, 选, 不中？不要， 中？ 要得！ 选.....选.....海选!\n\n```\nawk -f progfile optionnal list of files\n```\n\n那么选择的条件一多了， 不想一条条罗列了，怎么给婚介所一个范围？ 用到字段的数量 *NF* 了。 *NF* 是 *Awk* 计算当前行的字段数量并存储的内建的变量。\n\n```\n➜  tmp awk  '{ print NF, $1, $NF }' gfs.data \n4 Li 10000\n4 Wang 8000\n4 Niu 20000\n4 Chen 5000\n4 Ouyang 12000\n4 Liu 9999\n```\n这就打出每一个 boy 的 考察的条件数量，姓名，月收入了。直接拿这条件去撒网了。\n\n打印真名天子所在的相亲次序 *NR*, 也是一个内建变量，是计算到目前为止，读取到的行的数量, 这里就是相亲的次数（假设这妹子每次相亲都换人）。\n\n```\n➜  tmp awk '{print NR, $0}'  gfs.data\n1 Li 65 177 10000\n2 Wang 77 180 8000\n3 Niu 60 199  20000\n4 Chen 64.5 168 5000\n5 Ouyang 80 200 12000\n6 Liu 72.5 182 9999\n\n```\n\n这几个的条件呢？ \n\n```\n➜  tmp awk '$4 > 10000 {print \"很有钱的人:\", $1, \" 月收入:\", $4 }' gfs.data  \n很有钱的人: Niu  月收入: 20000\n很有钱的人: Ouyang  月收入: 12000\n```\n\n人太多了，薪资位数不好比较，毕竟 0 太多了嘛! 筛选一下并格式化一下， 怎么搞？ printf(format, val_1, val_2, val_3, ..., val_n), \n\n```\n➜  tmp awk '{printf(\"%-8s 的月薪是 ￥%10.2f\\n\", $1,$4)}' gfs.data\nLi       的月薪是 ￥  10000.00\nWang     的月薪是 ￥   8000.00\nNiu      的月薪是 ￥  20000.00\nChen     的月薪是 ￥   5000.00\nOuyang   的月薪是 ￥  12000.00\nLiu      的月薪是 ￥   9999.00\n\n```\n\n哎呀，还是看不清谁是优质男嘛，来，排下他们的薪资高低。 薪水往地处走，人往高处挑呀！ 用管道命令 *sort* 。\n\n```\n➜  tmp awk '{printf(\" %10.2f %s\\n\", $4, $0)}' gfs.data | sort -n\n    5000.00 Chen 64.5 168 5000\n    8000.00 Wang 77 180 8000\n    9999.00 Liu 72.5 182 9999\n   10000.00 Li 65 177 10000\n   12000.00 Ouyang 80 200 12000\n   20000.00 Niu 60 199  20000\n```\n原来牛哥是这里边最有 \"钱途\" 的！ 既然有三个是万元薪资的了，就先锁定他们了。毕竟谁会跟钱过不去？但是不能光看工资啊，要是这人是武大郎怎么办或者√2怎么办？ 不行，还是慎重一点，高开低走，190以上的，能过眼。长大了能像郎平和朱婷一样打排球，或者弄个小姚明？ 再加点条件吧： AND, OR 和 NOT, 用 &&, || 和 !\n\n```\n➜  tmp awk '$4 >=10000 && $3 > 190 { print $0}' gfs.data\nNiu 60 199  20000\nOuyang 80 200 12000\n```\n\n这个输出少了一个醒目的标题, 说不定有妹子错将体重看成是腰围呢？为避免不必要的误解发生，还是加个头吧。\n```\n➜  tmp awk 'BEGIN {print \"姓名 体重 身高 薪水\"; print \"\"}{print($0)}' gfs.data        \n姓名 体重 身高 薪水\n\nLi 65 177 10000\nWang 77 180 8000\nNiu 60 199  20000\nChen 64.5 168 5000\nOuyang 80 200 12000\nLiu 72.5 182 9999\n\n```\n\n哎呀，提前到约会地点了，闲着没事干，要么比较一下这些人的平均工资？\n\n```\n➜  tmp awk '{salary = salary + $4} END {print NR, \"个人\";  print \"总共月薪：\", salary; print \"平均月 薪:\", salary/NR}' gfs.data        \n6 个人\n总共月薪： 64999\n平均月薪: 10833.2\n```\n还不错嘛！人还没来，将所有相亲的人名品起来能组成一首诗么？ \n\n```\n➜  tmp awk '{names = names $1 \" \"} END {print names }'  gfs.data\nLi Wang Niu Chen Ouyang Liu \n```\n\n好吧，并没有。这些人名有多少笔画?啊不，是有几个字母组成？ \n\n```\n➜  tmp awk ' {print $1, length($1) } ' gfs.data\nLi 2\nWang 4\nNiu 3\nChen 4\nOuyang 6\nLiu 3\n```\n\n\n### 军刀的流程\n\n\nif-else 筛筛 \n\n```\n➜  tmp awk '$4 > 10000 {n =  n + 1; salary = salary + $4 }{ if (n > 0 && $4 > 10000)  print $1, \"你有戏哟\"; else {print $1, \"你被out了\"} }' gfs.data\nLi 你被out了\nWang 你被out了\nNiu 你有戏哟\nChen 你被out了\nOuyang 你有戏哟\nLiu 你被out了\n```\n\nwhile 循环, 从头梳理一边\n```\nawk '{ line[NR] = $0 } END { i = NR ;while (i>0) { print line[i]; i = i - 1 }} ' gfs.data\nLiu 72.5 182 9999\nOuyang 80 200 12000\nChen 64.5 168 5000\nNiu 60 199  20000\nWang 77 180 8000\nLi 65 177 10000\n```\n\nfor  九九归一\n```\n➜  tmp awk 'BEGIN {for (i=1; i <=9; ++i) print i}'                            \n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n```\n\n### 实用“片刀式”\n\n输入行的总行数\n\n```\n➜  tmp awk 'END { print NR}' gfs.data\n6\n```\n\n打印第四行 \n\n```\n➜  tmp awk ' NR == 4 ' gfs.data\nChen 64.5 168 5000\n```\n\n输出每一行最后一个字段 \n\n```\n➜  tmp awk ' {print $NF}' gfs.data\n10000\n8000\n20000\n5000\n12000\n9999\n```\n\n打印最后一行的最后一个字段\n\n```\n➜  tmp awk '{field = $NF} END { print field }'  gfs.data\n9999\n```\n\n打印字段数多于 3 个的输入行\n\n```\n➜  tmp awk 'NF>3' gfs.data\nLi 65 177 10000\nWang 77 180 8000\nNiu 60 199  20000\nChen 64.5 168 5000\nOuyang 80 200 12000\nLiu 72.5 182 9999\n```\n\n打印最后一个字段值大于10000的输入行\n\n```\n➜  tmp awk '$NF > 10000 ' gfs.data \nNiu 60 199  20000\nOuyang 80 200 12000\n\n```\n\n打印所有输入行的字段数的总和\n\n```\n➜  tmp awk ' {nf = nf + NF} END {print nf} ' gfs.data\n24\n```\n\n打印包含 /Niu/ 的行的数量\n\n```\n➜  tmp awk ' /Niu/ {nlines = nlines + 1} END {print nlines}' gfs.data\n1\n\n```\n\n打印具有最大值的第4个字段，以及包含它的行(假设 $1 总是正的)\n\n```\n➜  tmp awk '$4 > max { max=$4; maxline=$0 } END { print max, maxline }' gfs.data \n20000 Niu 60 199  20000\n```\n\n打印至少包含一个字段的行\n\n```\n➜  tmp awk 'NF > 0' gfs.data\nLi 65 177 10000\nWang 77 180 8000\nNiu 60 199  20000\nChen 64.5 168 5000\nOuyang 80 200 12000\nLiu 72.5 182 9999\n```\n\n打印长度超过 20 个字符的行 \n```\n➜  tmp awk 'length($0) > 16' gfs.data\nNiu 60 199  20000\nChen 64.5 168 5000\nOuyang 80 200 12000\nLiu 72.5 182 9999\n```\n\n每一行的前面加上它的字段数 \n```\n➜  tmp awk '{print NF, $0}'  gfs.data\n4 Li 65 177 10000\n4 Wang 77 180 8000\n4 Niu 60 199  20000\n4 Chen 64.5 168 5000\n4 Ouyang 80 200 12000\n4 Liu 72.5 182 9999\n```\n\n打印每行第二，第一字段\n\n```\n➜  tmp awk '{print $2, $1}' gfs.data\n65 Li\n77 Wang\n60 Niu\n64.5 Chen\n80 Ouyang\n72.5 Liu\n```\n\n交换一个字段并打印整行\n\n```\n➜  tmp awk '{tmp = $1; $1 = $2; $2 = tmp; print}' gfs.data\n65 Li 177 10000\n77 Wang 180 8000\n60 Niu 199 20000\n64.5 Chen 168 5000\n80 Ouyang 200 12000\n72.5 Liu 182 9999\n\n```\n\n每行的第一个字段用行号代替\n\n```\n➜  tmp awk  '{$1 = NR; print}' gfs.data\n1 65 177 10000\n2 77 180 8000\n3 60 199 20000\n4 64.5 168 5000\n5 80 200 12000\n6 72.5 182 9999\n\n```\n\n打印删除了第二个字段的行\n\n```\n➜  tmp awk '{$2 == \"\"; print}' gfs.data\nLi 65 177 10000\nWang 77 180 8000\nNiu 60 199  20000\nChen 64.5 168 5000\nOuyang 80 200 12000\nLiu 72.5 182 9999\n```\n\n每一行的字段按逆序打印\n\n```\n➜  tmp awk '{ for (i=NF; i > 0; i= i-1) {printf(\"%s \", $i)} printf(\"\\n\")}' gfs.data\n10000 177 65 Li \n8000 180 77 Wang \n20000 199 60 Niu \n5000 168 64.5 Chen \n12000 200 80 Ouyang \n9999 182 72.5 Liu \n\n```\n\n打印每一行的所有字段值之和\n\n```\n➜  tmp awk '{sum = 0; for (i=1; i <=NF; i=i+1) {sum = sum + $i} print sum }' gfs.data\n10242\n8257\n20259\n5232.5\n12280\n10253.5\n```\n\n将所有行的所有字段值累加起来 \n\n```\n➜  tmp awk  '{for (i=1; i<=NF; ++i) sum += $i} END {print sum}' gfs.data\n66524\n```\n\n将所有行的所有字段值的绝对值 \n\n```\n➜  tmp awk  '{for (i=1; i<=NF; ++i) if ($i < 0) {$i = -$i} print }'                  \nLi -65 -177 18000 # 这里手动输入带负数的值\nLi 65 177 18000 # 返回\n```\n\n### Awk 语言之萝卜白菜\n\n输入一个文件 就叫 `radish.data` 吧, 这个文件大体就是这样的, 这个小节就用这个萝卜白菜来拌炒鱼肉吧\n```\n➜  tmp awk 'BEGIN {print \"名称       重量 单价 分类\\n\"} {printf(\"%-10s %6.2f %2.2f %-1s\\n\", $1, $2, $3, $4)}' radish.data\n名称       重量 单价 分类\n\nFish        30.00 8.50 Meat\nRadish      14.00 1.20 Vegetables\nCabbage     24.00 1.50 Vegetables\nApple      100.00 2.50 Fruit\nOnion        8.00 0.80 Vegetables\nBanana      50.00 1.40 Fruit\nBeef       120.00 22.00 Meat\nRice        40.00 10.00 Staple\n```\n\n首先需要明确的是 Awk 炒的模式，有这么几种, 看过awk 起源之美女选男朋友的话，应该有 *似曾相识燕归去*的感觉。\n`BEGIN {statements} `\n  在输入被读取之前， statements 执行一次 , 就是不管你是爆炒还是水煮， 甭管你是鱼还是肉，你给我先洗洗!准备好油盐酱醋碗, 跟你炒没关系！\n`END {statements} `\n当所有输入读取完毕之后， statements 执行一次, 还是老话，管你吃饱没吃饱，你给我付钱！\n`expression {statements} `\n每碰到一个判断 expression 为真的输入行， statements 就执行一遍做菜流程. expression 为真的是其值非零或非空, 就是检查一下你放盐了没，油是不是太多了? 七分熟还是八分熟？\n`/regular expression/ {statements} `\n当碰到正则匹配的输入行时， statements就执行: 输入行含有一段字符串，而该字符串可以被 regular expression 匹配。一句话，老老实实按照菜谱来，要是在菜里被找到有头发或者小强便便，你丫就死定了！\n`compound pattern {statements}` \n多种模式， &&(AND), ||(OR), !(NOT), 以及括号组合起来。 当 `compound pattern` 为真时，statements执行。就是你可以 翻炒+添醋， 或者烘烤， 但是别给我整半生不熟的。\n`pattern_1, pattern_2 {statements} `\n一个范围模式匹配多个输入行，从pattern1 开始， 到 pattern_2 结束（包括这两行）, 对其中每一行执行statements操作。 你能露几手的环节可能就是在生火后，起锅前, 这段时间段，是你的表演时刻啊。\n\n\n可以将你的七十二路炒菜法写下来， 放到 `cooking` 秘籍里, \n```\nBEGIN { \n      printf(\"%-10s %s %s %s\\n\",\n          \"名称\", \"重量\", \"单价\", \"分类\")\n      }\n      { printf(\"%-10s %6.2f %6.2f %s\\n\", $1, $2, $3, $4)\n        weight = weight + $2\n        price  = price + $3*$2\n      }\nEND   { printf(\"\\n%10s %6.2f %6.2f\\n\", \"总共: \", weight, price)\n      }%\n```\n\n下次传给万中无一的练武奇才时， 直接调用 \n\n```\n➜  tmp awk -f cooking radish.data\n名称         重量 单价 分类\nFish        30.00   8.50 Meat\nRadish      14.00   1.20 Vegetables\nCabbage     24.00   1.50 Vegetables\nApple      100.00   2.50 Fruit\nOnion        8.00   0.80 Vegetables\nBanana      50.00   1.40 Fruit\nBeef       120.00  22.00 Meat\nRice        40.00  10.00 Staple\n\n      总共:  386.00 3674.20\n```\n\n### 刀片出鞘\n一枝军刀片，千军万马削倒一遍!\n欲知后事如何，且听不才我下回分解。。。。。。\n\n\n<!--more-->\n","tags":["灵犀指"]},{"title":"点子","url":"/2017-02-03-ideas/","content":"## 一些闪现的点子\n\n#### 自动记录围棋手数的棋盘\n\n今天重新看围棋视频的时候，还是发现，现在棋谱的记录仍然依赖人工手动输入的方式。\n有趣的是，2015年职业小将赵晨宇对战以为韩国棋手时，出现双方争执未找劫材就直接提劫的情况。\n重大比赛虽然一般都配备记谱员。不过从去年到现在都一直有职业棋手反映，根据棋谱讲解时，有些棋谱中很可能次序是错的。毕竟职业的比赛一盘棋下来，多的有的需要好几个小时。记谱员不可能像职业棋手一样一直集中那么多时间和精力到每一步上面。这个过程是有次序出错的可能的。但是围棋极其重要的就是次序，甚至就是那么一两步的次序，成就了各种妙味。\n然后，棋手下棋时还需要手动去按下计时器。有的棋手有时下棋太专注了，竟忘记了按钟，最后因为这个而丢掉了珍贵的比赛! 太讽刺了！这种分散注意力的按钟方式，不应该交给正在下棋的棋手。\n所以应该设计并实现一种自动准确记录棋谱的智能棋盘，将极大的解放棋谱记录者的工作, 复原比赛公正性，并给棋手比赛提供最专注的注意力。\n\n智能棋牌特点:\n- 自动记谱\n- 提供视频复盘\n- 智能记录耗时\n- 倒计时语音\n\n\n","tags":["点滴"]}]